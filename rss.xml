<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="http://dourok.info/rss.xml" rel="self" type="application/atom+xml" /><link href="http://dourok.info/" rel="alternate" type="text/html" /><updated>2021-04-16T02:56:13+00:00</updated><id>http://dourok.info/rss.xml</id><title type="html">DouO’s Blog</title><subtitle>有時樹會倒下，某片天頃刻明亮
</subtitle><entry><title type="html">夜骑凤凰山</title><link href="http://dourok.info/2018/09/26/night-ride-to-phoenix-mountine/" rel="alternate" type="text/html" title="夜骑凤凰山" /><published>2018-09-26T00:00:00+00:00</published><updated>2018-09-27T12:13:32+00:00</updated><id>http://dourok.info/2018/09/26/night-ride-to-phoenix-mountine</id><content type="html" xml:base="http://dourok.info/2018/09/26/night-ride-to-phoenix-mountine/">&lt;p&gt;&lt;img src=&quot;星空2.jpg&quot; alt=&quot;&quot; title=&quot;&amp;quot;纪念照&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;20 号夜 6 点半从汕头市区出发夜骑凤凰山。19：17 到达樟林，335 省道莲华段的路况不是太好，路窄大车多，水泥路面多处破裂，50左右速度过一处不平路面时，这次颠簸感觉到前轮有被『蛇咬』的可能性，一路有点担心爆胎。到意东镇后，想到接下来要离开市区，靠边停车检查一下车况，发现前轮胎压不足。开始有点担心是不是破胎泄气，不过想到前轮上次打气不知道是什么时候，起码得一年以上，说不定买车就没打过（😎）。还是自然泄气的可能性大一点。刚好前方不远意东三路和北桥路红灯路口有一家新本店，便跑去打了气，店主人不错也没收钱，检查了下没什么问题就继续出发了，准备开一段再看看胎压，最坏情况就在凤凰山住宿。摩托车胎没有公路车胎那么矫情（事实证明磕了一下没影响，车在山上停了一夜气还是饱的）&lt;/p&gt;

&lt;p&gt;过了文祠镇就是山路了，山路基本没有路灯，一路远光，会车自觉关灯，但迎面来的汽车能做到自觉关灯不到三成，痛恨不已，遇到不关灯，为了避免会车后的短暂失明，只能低头减速。有一处一边路面修路封掉，迎面来的汽车还不关灯，简直是谋杀，幸好速度足够低才能避免这些危险。不过这段路还是得花多白天一倍的时间。&lt;/p&gt;

&lt;p&gt;大概 9 点到凤凰镇，在 201 乡道停留休息了一下，开始走老路上山。晚上走老路还是很有挑战性的，而且快到凤溪水库那边，摩托车开始出现异响（往右压弯会出现），虽然大概知道是链条太松了，不过听着还是很紧张。爬升高一点开始有雾，当晚本来有月的（八月十一），不过在云里开车，能见度很差，有几次拐弯，以为弯道要完了结果还没有，只能急忙刹车减速。还有一次以为车辆要失控了，还用脚踩一下地面保持平衡。后面就不敢分神和后面那位叨叨，精神高度集中，老路两边有不少房子，山上人家大多早早休息。到了乌崬村左拐往天池方向的时候，摩托车刚好开到云上面，豁然开朗，满天繁星，月光下周围是望不到边际的云海，不远处的山峰耸立在云海上方，夜幕下显得壮观又可怖。因为时间太晚，又快到顶了，便没有停车拍照，实在可惜，10点左右到天池入口停车场时刚停好车云雾又来了。&lt;/p&gt;

&lt;p&gt;准备收拾东西爬天池的时候，发现居然忘了带水袋，列好了清单事无巨细，一件件打钩就是忘了把水袋放进书包里，10 点的停车场售票处都已没有人，绕了一圈找不到商铺或者装水的容器。有点不知所措，既然没带水袋，那就灵活变通将错就错。解决晚餐再上去。直接在景区门口铺上防潮垫，席地而坐。地面平，离公厕近，接水洗锅都方便。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;牛肉丸.jpg&quot; alt=&quot;&quot; title=&quot;牛肉丸、生菜、煮方便面，几口热汤下肚就是满满的幸福感，10 颗牛肉丸还是吃的很满足&quot; /&gt;&lt;/p&gt;

&lt;p&gt;吃完刷了牙，带上头灯继续上路，售票处没有人，门还留了条通道，直接就逃票上去了。其实就算门没关还是可以从售票处后边绕过去的。这里到天池大概是 1200m，在800m、200m 处都有路牌提示。全程石梯和围栏，雾非常浓，大功率头灯也照不清2米外，慢慢走十几二十分钟就能到天池，总的来说不算陡，地图上看爬升大概 130m。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;售票处.jpg&quot; alt=&quot;&quot; title=&quot;票价 30，三年前来的时候还是 20。左边的通道可以绕过正门 &quot; /&gt;&lt;/p&gt;

&lt;p&gt;爬上去就看到雾里有亮光，随着灯光走过去，原来是另一伙露营的人。几男几女，两个帐篷。他们在走廊下露营，打了下招呼，就继续沿着走廊走。就在过了亭后的平地，抵着两个石头的地方搭起帐篷。因为雾太重不敢乱走，人也太累，心念念的薯片都没吃就躺下了。这个帐篷位置选的实在不好，离那伙人太近，他们一晚上都在聊天，在天池里抓鱼还大声嚷嚷。4 点多的时候又有一伙人在亭里休息喝茶聊天。基本一夜都没睡好。不过，幸好没睡好。3点出头的时候，听到他们沸腾起来，喊着看星星。&lt;/p&gt;

&lt;p&gt;打开帐篷一看，雾都散开了。满天繁星，无一点云，实在美妙。还看到几颗流星。连忙叫起同伴，起来看星星，拍几张纪念照，总算不枉此行。没带脚架很难找角度，军事中心的灯光污染了一部分天区。时间有限，准备不足所以照片都是纪念照。没多久，雾又来了。安心躺下休息了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;星空1.jpg&quot; alt=&quot;&quot; title=&quot;灯光污染&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5点多起来看了下又都是雾，实在太困，就不去碰运气看日出了。云海和雾真的是一线之间。这个时间段没有人来，只有远处几个摘茶工聊天的声音，终于能安安静静睡一觉了。
不过到七点多睡不下去了，就起来刷牙吃早餐。原来天池也是有厕所的，就在露营点走一段楼梯就到了。而且前面就是一大片草地，早上雾散了终于看清楚，昨晚这个营点选的实在不好。吃完早餐吃零食喝茶聊天。9点出头就收拾东西，到处逛逛。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;广角.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;回程准备去探探西北方向的路。顺便去那边的天子洞之类的景点。9点多的太阳实在是毒辣，沿着天池边走一段小路，左手边还有两个池塘，经过两个亭，在军事雷达下方的那个亭休息了会，看似路程还很远，似乎与回程的路线不通，太阳又毒辣，便决定往回走，到蘑菇亭方向的小路往上走，便是西北方向下山的路。&lt;/p&gt;

&lt;p&gt;路是普通的山路，碎石比较多。走到尽头出大路的时候被一个铁门锁住了，两边还围了铁丝网。不过这个铁门轻易就翻过去。大路也是山土路，能通车。全程遇到过两辆车，不过长了很多，得两倍景区路线的距离，地图上测距大概 2 公里，不过还算好走，11点前顺利达到停车场。快点停车场的时候我以为出口的路也被封了，吓死了。便放下行李和同伴先去探探路，幸好是看错了，将错就错直接开摩托回来接同伴。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;路线.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;铁门.jpg&quot; alt=&quot;&quot; title=&quot;这里不能通行&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下山的时候又想碰碰运气，便走了新路，新路有路牌写明不允许摩托车行驶，酒店那里有设卡，不过大中午没有人，而且还留有一个摩托车可过的通道，我就不管直接通过了。快到凤凰镇的时候也有一个卡口，不过同样留有一个摩托车可通过的卡口，还有保安。自然镇定慢速通过，没有什么事，最后顺利到达凤凰镇，走新路下山果然快很多，慢速安全驾驶也只需半小时不到。白天开车也快很多。11点从天池停车场下来，1 点就到樟林。结束了19个小时的凤凰山之旅。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;新路老路.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;写一篇流水账记录，给自己以后也给有需要的朋友一些参考，客观上也透露了一些逃票的参考信息，并不是我鼓励逃票，如果可以还请花钱买票支持当地的旅游业和环境保护。不过对于中国景区的私人经营、收费过高、商业化运作过重的问题，也是深痛恶绝（并非指天池），所以对于逃票行为也是只能不予置评了。&lt;/p&gt;</content><author><name></name></author><category term="life" /><category term="凤凰山" /><category term="摩旅" /><category term="星空" /><summary type="html">20 号夜 6 点半从汕头市区出发夜骑凤凰山。19：17 到达樟林，335 省道莲华段的路况不是太好，路窄大车多，水泥路面多处破裂，50左右速度过一处不平路面时，这次颠簸感觉到前轮有被『蛇咬』的可能性，一路有点担心爆胎。到意东镇后，想到接下来要离开市区，靠边停车检查一下车况，发现前轮胎压不足。开始有点担心是不是破胎泄气，不过想到前轮上次打气不知道是什么时候，起码得一年以上，说不定买车就没打过（😎）。还是自然泄气的可能性大一点。刚好前方不远意东三路和北桥路红灯路口有一家新本店，便跑去打了气，店主人不错也没收钱，检查了下没什么问题就继续出发了，准备开一段再看看胎压，最坏情况就在凤凰山住宿。摩托车胎没有公路车胎那么矫情（事实证明磕了一下没影响，车在山上停了一夜气还是饱的） 过了文祠镇就是山路了，山路基本没有路灯，一路远光，会车自觉关灯，但迎面来的汽车能做到自觉关灯不到三成，痛恨不已，遇到不关灯，为了避免会车后的短暂失明，只能低头减速。有一处一边路面修路封掉，迎面来的汽车还不关灯，简直是谋杀，幸好速度足够低才能避免这些危险。不过这段路还是得花多白天一倍的时间。 大概 9 点到凤凰镇，在 201 乡道停留休息了一下，开始走老路上山。晚上走老路还是很有挑战性的，而且快到凤溪水库那边，摩托车开始出现异响（往右压弯会出现），虽然大概知道是链条太松了，不过听着还是很紧张。爬升高一点开始有雾，当晚本来有月的（八月十一），不过在云里开车，能见度很差，有几次拐弯，以为弯道要完了结果还没有，只能急忙刹车减速。还有一次以为车辆要失控了，还用脚踩一下地面保持平衡。后面就不敢分神和后面那位叨叨，精神高度集中，老路两边有不少房子，山上人家大多早早休息。到了乌崬村左拐往天池方向的时候，摩托车刚好开到云上面，豁然开朗，满天繁星，月光下周围是望不到边际的云海，不远处的山峰耸立在云海上方，夜幕下显得壮观又可怖。因为时间太晚，又快到顶了，便没有停车拍照，实在可惜，10点左右到天池入口停车场时刚停好车云雾又来了。 准备收拾东西爬天池的时候，发现居然忘了带水袋，列好了清单事无巨细，一件件打钩就是忘了把水袋放进书包里，10 点的停车场售票处都已没有人，绕了一圈找不到商铺或者装水的容器。有点不知所措，既然没带水袋，那就灵活变通将错就错。解决晚餐再上去。直接在景区门口铺上防潮垫，席地而坐。地面平，离公厕近，接水洗锅都方便。 吃完刷了牙，带上头灯继续上路，售票处没有人，门还留了条通道，直接就逃票上去了。其实就算门没关还是可以从售票处后边绕过去的。这里到天池大概是 1200m，在800m、200m 处都有路牌提示。全程石梯和围栏，雾非常浓，大功率头灯也照不清2米外，慢慢走十几二十分钟就能到天池，总的来说不算陡，地图上看爬升大概 130m。 爬上去就看到雾里有亮光，随着灯光走过去，原来是另一伙露营的人。几男几女，两个帐篷。他们在走廊下露营，打了下招呼，就继续沿着走廊走。就在过了亭后的平地，抵着两个石头的地方搭起帐篷。因为雾太重不敢乱走，人也太累，心念念的薯片都没吃就躺下了。这个帐篷位置选的实在不好，离那伙人太近，他们一晚上都在聊天，在天池里抓鱼还大声嚷嚷。4 点多的时候又有一伙人在亭里休息喝茶聊天。基本一夜都没睡好。不过，幸好没睡好。3点出头的时候，听到他们沸腾起来，喊着看星星。 打开帐篷一看，雾都散开了。满天繁星，无一点云，实在美妙。还看到几颗流星。连忙叫起同伴，起来看星星，拍几张纪念照，总算不枉此行。没带脚架很难找角度，军事中心的灯光污染了一部分天区。时间有限，准备不足所以照片都是纪念照。没多久，雾又来了。安心躺下休息了。 5点多起来看了下又都是雾，实在太困，就不去碰运气看日出了。云海和雾真的是一线之间。这个时间段没有人来，只有远处几个摘茶工聊天的声音，终于能安安静静睡一觉了。 不过到七点多睡不下去了，就起来刷牙吃早餐。原来天池也是有厕所的，就在露营点走一段楼梯就到了。而且前面就是一大片草地，早上雾散了终于看清楚，昨晚这个营点选的实在不好。吃完早餐吃零食喝茶聊天。9点出头就收拾东西，到处逛逛。 回程准备去探探西北方向的路。顺便去那边的天子洞之类的景点。9点多的太阳实在是毒辣，沿着天池边走一段小路，左手边还有两个池塘，经过两个亭，在军事雷达下方的那个亭休息了会，看似路程还很远，似乎与回程的路线不通，太阳又毒辣，便决定往回走，到蘑菇亭方向的小路往上走，便是西北方向下山的路。 路是普通的山路，碎石比较多。走到尽头出大路的时候被一个铁门锁住了，两边还围了铁丝网。不过这个铁门轻易就翻过去。大路也是山土路，能通车。全程遇到过两辆车，不过长了很多，得两倍景区路线的距离，地图上测距大概 2 公里，不过还算好走，11点前顺利达到停车场。快点停车场的时候我以为出口的路也被封了，吓死了。便放下行李和同伴先去探探路，幸好是看错了，将错就错直接开摩托回来接同伴。 下山的时候又想碰碰运气，便走了新路，新路有路牌写明不允许摩托车行驶，酒店那里有设卡，不过大中午没有人，而且还留有一个摩托车可过的通道，我就不管直接通过了。快到凤凰镇的时候也有一个卡口，不过同样留有一个摩托车可通过的卡口，还有保安。自然镇定慢速通过，没有什么事，最后顺利到达凤凰镇，走新路下山果然快很多，慢速安全驾驶也只需半小时不到。白天开车也快很多。11点从天池停车场下来，1 点就到樟林。结束了19个小时的凤凰山之旅。 写一篇流水账记录，给自己以后也给有需要的朋友一些参考，客观上也透露了一些逃票的参考信息，并不是我鼓励逃票，如果可以还请花钱买票支持当地的旅游业和环境保护。不过对于中国景区的私人经营、收费过高、商业化运作过重的问题，也是深痛恶绝（并非指天池），所以对于逃票行为也是只能不予置评了。</summary></entry><entry><title type="html">读 Clean Architecture</title><link href="http://dourok.info/2018/07/08/clean-architecture/" rel="alternate" type="text/html" title="读 Clean Architecture" /><published>2018-07-08T00:00:00+00:00</published><updated>2018-09-27T03:55:25+00:00</updated><id>http://dourok.info/2018/07/08/clean-architecture</id><content type="html" xml:base="http://dourok.info/2018/07/08/clean-architecture/">&lt;h1 id=&quot;架构是什么&quot;&gt;架构是什么？&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;The boxes on a PowerPoint diagram are not a software system’s architecture.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;近来读了 Uncle Bob 的 《清晰架构》(Clean Architecture)，副标题叫『一个工匠的软件结构与设计指南』，自称为工匠的 Uncle Bob 全名叫 &lt;a href=&quot;https://en.wikipedia.org/wiki/Robert_C._Martin&quot;&gt;Robert C. Martin&lt;/a&gt;，是一位有 50 多年经验的软件工程师和作者。他是 SOLID 原则的命名者，同时也是《&lt;a href=&quot;https://book.douban.com/subject/1140457/&quot;&gt;敏捷软件开发&lt;/a&gt;》、《&lt;a href=&quot;https://book.douban.com/subject/4199741/&quot;&gt;代码整洁之道&lt;/a&gt;》的作者。《清晰架构》是 17 年出版的书也算是今年读的比较新的书了。全书分 35 章，近 400 页，虽说也不算特别多，不过啃下英文版也颇为吃力。本书听起来像是专业软件架构论述，其实更像是作者的杂谈，不少内容都可以在作者过去的博客找到。其中的软件开发哲学的故事让我很感兴趣。&lt;/p&gt;

&lt;p&gt;那么什么是架构呢？作为一个常常把架构挂在嘴边的人，要给架构下个定义还真不容易。书中 Uncle Bob 给了一个很棒的定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;软件架构是指，设计软件的人为软件赋予的形状，这个形状是指系统如何被划分为&lt;strong&gt;组件(Components)&lt;/strong&gt;，各个组件如何&lt;strong&gt;排列（Arrangement）&lt;/strong&gt;，组件之间如何&lt;strong&gt;沟通（Communication）&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://www.inoreader.com/article/3a9c6e7ec00599d2-clean-architecture1&quot;&gt;搞笑搞软工&lt;/a&gt;用了公司的组织架构来类比，我觉得非常形象：一个中型公司有董事会、董事长、董事会、总经理、部门、组等，以及各部门里面的员工，由此形成组织架构图。可以看出所有的架构一定有三个东西：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;构成组织的单元，也就是不同职能的员工。&lt;/li&gt;
  &lt;li&gt;人员的安排，阶层式、扁平式、矩阵式，等等。&lt;/li&gt;
  &lt;li&gt;人员沟通的方式，直接沟通、透过部门主管或PM与其他部门或外部客户与厂商沟通、禁止沟通、圣上垂询才可开口等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了组织架构外，公司还有他的业务，业务与架构是决定一家公司的两个维度，两者看似正交，实际当我们看到一家公司的架构图，我们大概也能猜出一星半点公司的业务，法务部或行政部可能看不出什么，但移动开发部很明显喊着公司有着移动开发的业务（&lt;a href=&quot;http://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html&quot;&gt;Screaming Architecture&lt;/a&gt;）。往往业务的发展会导致架构的演化，架构的演化反过来促进业务的发展。&lt;/p&gt;

&lt;p&gt;软件系统也是同样的道理，软件有两个量（Value）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;软件的功能或行为，就是业务&lt;/li&gt;
  &lt;li&gt;软件的形状或设计，也就是所谓的架构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;功能衡量系统能不能满足需求？架构意味着系统是否易于变化。功能架构孰重要？作者在书中用了控制变量法来说明这个问题，假设有两个系统：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个系统能完全的满足需求但是不可变。&lt;/li&gt;
  &lt;li&gt;一个系统完全不可用，但是易于改变。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大部分人直觉上会选择那个马上就能跑起来的系统。但哪个系统更没用呢？第一个系统虽然能用，但是一旦需求变化了便不能用了，可能有点比较难想象，换句话说是修改系统的成本高于修改系统的收益，因为他非常难以更改。第二个系统虽然不能满足业务需要，但是它可以持续改善并最终变得有用。&lt;/p&gt;

&lt;p&gt;若说架构比功能还有价值，又不合常理，一个精雕细琢的没有价值的软件，没有金主会为它埋单哪能诞生？除非是『软件艺术家』的自发行为。对一家软件公司来说，软件是其产品，产品要带来收益，所以功能仍是软件的第一价值，功能是软件能产生价值的部分。关系到我们的金主能不能赚到钱。架构退而次之是软件的第二价值，影响到软件的生命周期中的各种成本，间接地影响金主的收益。两者在软件不同的生命周期发挥着不同的作用，功能更多的是其紧急且重要部分，架构更多的是重要非紧急部分。&lt;/p&gt;

&lt;p&gt;关于架构的意义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;为了能够最小化创建和维护软件的成本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;真实的软件开发是一个挣扎（Struggle）的过程，程序员会想着多快好省实现需求解决 Bug，产品会在软件的开发阶段多次变更需求，市场会卡着上线时间。倘若把功能是否实现作为标准，理性又短视的程序员会最小化自己的投入，只顾着实现软件的功能和应付变更，忽视任何架构方面的问题，一个不好的架构下各种混乱的依赖下的相互作用其维护成本可能是指数增长的，最终项目全变成意大利面条式的代码（Spaghetti code），挖坑的人可能已经换了一批又一批，而这些技术债务的主体并不是欠下债务的程序员，而是软件的所有人。一个本应为公司带来技术积累的项目，反而成为公司的历史包袱。&lt;/p&gt;

&lt;p&gt;可能有勇士在某个时间点（维护成本不断增加直到高于重构成本的那个拐点）会提出重构可以解决问题。但重构只是可以解决一部分问题，可能还会引入新的问题。对于这种情况，作者这样说：如果最后才考虑架构，那么系统的开发成本会更高，并且最终几乎不可能成为系统的一部分。如果允许这种情况发生，则意味着软件开发团队没有做足够的努力。我们站在 PM 的角度看，他只关心需求，他们不懂也没有能力评估架构的重要性，因为这对他们来说是无关的细节。所以架构师必须要责任去强调架构的重要性，在开发过程中争取足够的时间进行架构设计。&lt;/p&gt;

&lt;p&gt;有一点是确定，架构设计和单元测试确实会使项目的开发变慢，而债务也不一定是坏事，在一些时间点欠点技术债是可以获得更好的投资回报率。这一点在现实生活中可以找到很多应用，比如贷款买房，炒股加杠杆。在资源有限的情况下，功能和设计确实是一对矛盾，架构师的职责换一种表述就是利用其专业知识为功能和设计分配资源以获得最佳的回报率。&lt;/p&gt;

&lt;p&gt;对于架构师的职责作者这样说，设计良好的架构，使系统易于理解、开发、维护和部署。最终目标是最大限度地降低系统的生命周期成本并最大限度地提高程序员的生产力。&lt;/p&gt;

&lt;h1 id=&quot;架构设计之道&quot;&gt;架构设计之道&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Change is the only constant.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果说软件开发中有不变的真理，那就是&lt;strong&gt;变化不可避免&lt;/strong&gt;。为了应付变化。软件工程师总结出许多原则，比如封装变化，针对接口编程，依赖抽象，最少知识原则等等。&lt;/p&gt;

&lt;p&gt;记得很久以前开始思考软件的设计的时候，最常犯的错误就是，为了减少代码量而设计，特别是滥用继承，导致代码僵化重构后面对变化更加痛苦，如果当时了解了种种原则，生活肯定容易许多。&lt;/p&gt;

&lt;p&gt;本书用了三分之一的篇幅来讲这些原则。包括用于指导如何设计&lt;strong&gt;类&lt;/strong&gt;的 &lt;a href=&quot;https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)&quot;&gt;SOLID 原则&lt;/a&gt;，和指导如何设计组件的六个原则。这里&lt;strong&gt;类&lt;/strong&gt;不单单是面向对象的概念，而是更加泛化地指一组函数和数据，也称为模块（module）。 而组件指的是，指的是独立的可部署单元，是模块的集合。比如 java 中的 jar，ruby 的 gem。&lt;/p&gt;

&lt;p&gt;SOLID 原则指导类的设计应该容忍变化、易于理解。组件原则指导组件的内聚和组件间的耦合，其实也是 java 的分包原则。&lt;/p&gt;

&lt;p&gt;组件内聚：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;重用发布等价原则（Release/Reuse Equivalency Principle）&lt;/li&gt;
  &lt;li&gt;共同封闭原则（Common Closure Principle）&lt;/li&gt;
  &lt;li&gt;共同重用原则（Common Reuse Principle）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;组件耦合：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;无环依赖原则 ADP（Acycle Dependencies Principle）&lt;/li&gt;
  &lt;li&gt;稳定依赖原则 SDP（Stable Dependencies Principle）&lt;/li&gt;
  &lt;li&gt;稳定抽象原则 SAP（Stable Abstractions Principle）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;篇幅所限就不进行解释了，作者还介绍了两个度量组件稳定性和抽象性的量：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不稳定性：\(I = F_{out}/(F_{in}+F_{out})\)，\(F_{in}\) 传入依赖；\(F_{out}\) 传出依赖。依赖关系应该，高 I 值依赖低 I 值。&lt;/li&gt;
  &lt;li&gt;抽象性：\(A = N_a/N_c\)，\(N_c\) 类的数目；\(N_a\) 抽象类或接口的数目。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作者还聊了编程范式的发展，他的观点也挺有意思：编程的发展，是一个添加限制的过程。三种范式都从我们身上夺走了一些东西。每一种都限制了我们编写代码的方式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;结构化编程，对直接控制转移进行了限制&lt;/li&gt;
  &lt;li&gt;面向对象编程，对间接控制转移进行了控制&lt;/li&gt;
  &lt;li&gt;函数式编程，对变量分配进行了限制&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;面向对象最核心的就是增强了多态，引入多态后，高级函数依赖于低级函数的接口，而不是具体实现。把对具体实现的依赖分离出来。低级的实现，可以被独立部署更替。这就是依赖反转。对架构师来说提供了使用多态性来获得对系统中每个源代码依赖关系的绝对控制的能力。&lt;/p&gt;

&lt;p&gt;另外，Dijkstra 《Go To Statement Considered Harmful》的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%9C%89%E5%AE%B3&quot;&gt;故事&lt;/a&gt;也值得了解一下。&lt;/p&gt;

&lt;h1 id=&quot;清晰架构&quot;&gt;清晰架构&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Every problem in computer science can be solved with a layer of indirection (besides the problem of too many layers of indirection)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;清晰架构，在 2011 年作者的博客就有提到这个名词 &lt;a href=&quot;http://blog.cleancoder.com/uncle-bob/2011/11/22/Clean-Architecture.html&quot;&gt;Clean Architecture&lt;/a&gt;，另一篇引用比较多的博文 &lt;a href=&quot;http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&quot;&gt;The Clean Architecture&lt;/a&gt; 写于 12 年，内容所讲的就是本书的清晰架构。&lt;/p&gt;

&lt;p&gt;所以，清晰架构不是什么新东西，他是六边形架构(Hexagonal Architecture)的一个变体，基于以往多种架构的发展和归纳，提出来的一个新架构模型。&lt;/p&gt;

&lt;p&gt;传统的分层架构是垂直形式的层次架构，清晰架构是由外往内的圆环状层次架构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1200/0*JD606Sqx6RYZLKdu.&quot; alt=&quot;图片来源：https://android.jlelse.eu/thoughts-on-clean-architecture-b8449d9d02df&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样架构有几个特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个核心&lt;/li&gt;
  &lt;li&gt;抽象性往内递增&lt;/li&gt;
  &lt;li&gt;外层依赖内层&lt;/li&gt;
  &lt;li&gt;层与层之间通过接口与适配器进行交流&lt;/li&gt;
  &lt;li&gt;框架、数据库、UI 等都是细节&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;核心的实体指的就是领域内的关键业务逻辑，最不可能发生变化的部分，比如苹果总是往下掉；保险总有承保人、投保人、被保险人、受益人；还贷的等额本息、等额本金算法。关键业务逻辑应该是系统中最独立和可重用的代码。&lt;/p&gt;

&lt;p&gt;第二层是用例，用例是应用程序的业务逻辑。用例关注与输入数据并产生输出数据，但用例对象不应去关心数据如何传递给用户或其他任何组件。&lt;/p&gt;

&lt;p&gt;接着是接口适配层，将实体和用例转化为更适用外层使用的形式。将外部数据转化为用例或实体使用的内部形式。这一层最强大的工具就是依赖倒置，以 MVP 为例，更新界面的时候，控制流的方向 Presenter -&amp;gt; UI，而依赖关系却是 UI 依赖于 Presenter 层（实现了 Presenter 层相应的 View 接口）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;dip.png&quot; alt=&quot;依赖倒置使得依赖关系与控制流的方向相反&quot; /&gt;&lt;/p&gt;

&lt;p&gt;UI 在外层这个理所当然了，名字本身就说明了它直接和用户打交道，而且 UI 是掌控在设计和产品手里，越不能控制的东西越要小心其变化。&lt;/p&gt;

&lt;p&gt;传统的分层结构，数据库总是处于最底层，但其中数据才是关键，数据库不是。关系型数据库只不过是把数据按 b+ 树这样的结构存储起来，然后通过 SQL 来操作数据。我们也可以使用文件存储数据，甚至可以脱离硬盘直接在内存里面用数组、链表、树、图等数据结构组织我们的数据，毕竟内存价格越来越便宜了（五年一个取样，就可以无视近几年 PC 内存的涨幅了😆）。其中关键的点就是&lt;strong&gt;推迟决定&lt;/strong&gt;，我们很难在初期对我们的数据使用场景做个准确的预测，数据库作为细节隔离在核心系统外，以后因为性能规模等等问题变动数据库更加容易。&lt;/p&gt;

&lt;p&gt;但框架呢？框架总是鼓励我们和应用程序紧密的耦合在一起，它提供一种模式，只要我们服从这个模式就能获得极大的便利，代价就是这个框架和我们应用的各个层次紧密地耦合在一起。这有什么风险？其一，框架也许可以帮助您完成应用程序的一些早期功能。 但是随着产品的成熟，它可能会超出框架的功能。其二，框架可能会朝着你没有帮助的方向发展，你甚至可能会发现 API 消失、改变了，因为控制权在作者而不是在你手上。其三就是总有新框架出来，你可能希望切换到更新更好的框架。&lt;/p&gt;

&lt;p&gt;最近一个朋友维护老项目遇到一个 &lt;a href=&quot;https://github.com/loopj/android-async-http&quot;&gt;android-async-http&lt;/a&gt; 的&lt;a href=&quot;https://github.com/loopj/android-async-http/issues/1001&quot;&gt;问题&lt;/a&gt;向我求助，android-async-http！！！这个不是我一开始做 Android 项目用的网络库吗？起码也是 11、12 年的事了。虽然是个不错的库但也不维护几年了吧。遇到底层的 Bug 别提有多棘手了，而且维护的价值已不大，投入太多时间又觉得亏，最终只能用一些额外的措施把它掩盖过去。&lt;/p&gt;

&lt;p&gt;但分离框架，谈何容易呢。这几年写的 App，数据层也从手写 Dao 到 greenDao 到 DBFlow 再到现在的 Room。Room 虽然有官方加持，但以谷歌的尿性被弃用也是随时的事。如果引入 Room，最内层的 Entity 就得使用 Room 的注解便会对 Room 的依赖。如果要分离呢，就需要在数据层也定义一套 Entity，层层之间的数据传递还需要做转换，把核心的 Entity 转换为数据层的 Entity，这样做就很清晰架构了&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，但是有必要吗？&lt;/p&gt;

&lt;p&gt;架构的矛盾在于，我们不应该预见抽象的必要性。知道 YAGNI（You aren’t gonna need it）吗？这是个饱含智慧的理念：“你不需要它。”。因为过度工程往往比不够工程化更糟糕。典型的移动应用程序与典型的企业应用程序有很大不同。它要小得多，并且通常需要快速交付。记住架构是演化的，不能简单地在项目的开始时决定实施哪些边界以及忽略哪些边界。相反，随着系统的发展，边界会慢慢变的清晰，你会关注到它，再权衡实施和忽略的成本，在实施成本低于忽略成本的拐点时做出决定。&lt;/p&gt;

&lt;p&gt;不能手里有个锤子看到什么都是钉子。就像当初学设计模式一样，学了之后又要让你忘掉它。&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://github.com/android10/Android-CleanArchitecture&quot;&gt;Android-CleanArchitecture&lt;/a&gt; 就是这样的设计，但在 &lt;a href=&quot;https://fernandocejas.com/2018/05/07/architecting-android-reloaded/&quot;&gt;Kotlin 版&lt;/a&gt;已经不用了。 &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><category term="coder" /><category term="架构" /><category term="软件工程" /><summary type="html">架构是什么？ The boxes on a PowerPoint diagram are not a software system’s architecture. 近来读了 Uncle Bob 的 《清晰架构》(Clean Architecture)，副标题叫『一个工匠的软件结构与设计指南』，自称为工匠的 Uncle Bob 全名叫 Robert C. Martin，是一位有 50 多年经验的软件工程师和作者。他是 SOLID 原则的命名者，同时也是《敏捷软件开发》、《代码整洁之道》的作者。《清晰架构》是 17 年出版的书也算是今年读的比较新的书了。全书分 35 章，近 400 页，虽说也不算特别多，不过啃下英文版也颇为吃力。本书听起来像是专业软件架构论述，其实更像是作者的杂谈，不少内容都可以在作者过去的博客找到。其中的软件开发哲学的故事让我很感兴趣。 那么什么是架构呢？作为一个常常把架构挂在嘴边的人，要给架构下个定义还真不容易。书中 Uncle Bob 给了一个很棒的定义： 软件架构是指，设计软件的人为软件赋予的形状，这个形状是指系统如何被划分为组件(Components)，各个组件如何排列（Arrangement），组件之间如何沟通（Communication）。 搞笑搞软工用了公司的组织架构来类比，我觉得非常形象：一个中型公司有董事会、董事长、董事会、总经理、部门、组等，以及各部门里面的员工，由此形成组织架构图。可以看出所有的架构一定有三个东西： 构成组织的单元，也就是不同职能的员工。 人员的安排，阶层式、扁平式、矩阵式，等等。 人员沟通的方式，直接沟通、透过部门主管或PM与其他部门或外部客户与厂商沟通、禁止沟通、圣上垂询才可开口等。 除了组织架构外，公司还有他的业务，业务与架构是决定一家公司的两个维度，两者看似正交，实际当我们看到一家公司的架构图，我们大概也能猜出一星半点公司的业务，法务部或行政部可能看不出什么，但移动开发部很明显喊着公司有着移动开发的业务（Screaming Architecture）。往往业务的发展会导致架构的演化，架构的演化反过来促进业务的发展。 软件系统也是同样的道理，软件有两个量（Value）： 软件的功能或行为，就是业务 软件的形状或设计，也就是所谓的架构 功能衡量系统能不能满足需求？架构意味着系统是否易于变化。功能架构孰重要？作者在书中用了控制变量法来说明这个问题，假设有两个系统： 一个系统能完全的满足需求但是不可变。 一个系统完全不可用，但是易于改变。 大部分人直觉上会选择那个马上就能跑起来的系统。但哪个系统更没用呢？第一个系统虽然能用，但是一旦需求变化了便不能用了，可能有点比较难想象，换句话说是修改系统的成本高于修改系统的收益，因为他非常难以更改。第二个系统虽然不能满足业务需要，但是它可以持续改善并最终变得有用。 若说架构比功能还有价值，又不合常理，一个精雕细琢的没有价值的软件，没有金主会为它埋单哪能诞生？除非是『软件艺术家』的自发行为。对一家软件公司来说，软件是其产品，产品要带来收益，所以功能仍是软件的第一价值，功能是软件能产生价值的部分。关系到我们的金主能不能赚到钱。架构退而次之是软件的第二价值，影响到软件的生命周期中的各种成本，间接地影响金主的收益。两者在软件不同的生命周期发挥着不同的作用，功能更多的是其紧急且重要部分，架构更多的是重要非紧急部分。 关于架构的意义： 为了能够最小化创建和维护软件的成本。 真实的软件开发是一个挣扎（Struggle）的过程，程序员会想着多快好省实现需求解决 Bug，产品会在软件的开发阶段多次变更需求，市场会卡着上线时间。倘若把功能是否实现作为标准，理性又短视的程序员会最小化自己的投入，只顾着实现软件的功能和应付变更，忽视任何架构方面的问题，一个不好的架构下各种混乱的依赖下的相互作用其维护成本可能是指数增长的，最终项目全变成意大利面条式的代码（Spaghetti code），挖坑的人可能已经换了一批又一批，而这些技术债务的主体并不是欠下债务的程序员，而是软件的所有人。一个本应为公司带来技术积累的项目，反而成为公司的历史包袱。 可能有勇士在某个时间点（维护成本不断增加直到高于重构成本的那个拐点）会提出重构可以解决问题。但重构只是可以解决一部分问题，可能还会引入新的问题。对于这种情况，作者这样说：如果最后才考虑架构，那么系统的开发成本会更高，并且最终几乎不可能成为系统的一部分。如果允许这种情况发生，则意味着软件开发团队没有做足够的努力。我们站在 PM 的角度看，他只关心需求，他们不懂也没有能力评估架构的重要性，因为这对他们来说是无关的细节。所以架构师必须要责任去强调架构的重要性，在开发过程中争取足够的时间进行架构设计。 有一点是确定，架构设计和单元测试确实会使项目的开发变慢，而债务也不一定是坏事，在一些时间点欠点技术债是可以获得更好的投资回报率。这一点在现实生活中可以找到很多应用，比如贷款买房，炒股加杠杆。在资源有限的情况下，功能和设计确实是一对矛盾，架构师的职责换一种表述就是利用其专业知识为功能和设计分配资源以获得最佳的回报率。 对于架构师的职责作者这样说，设计良好的架构，使系统易于理解、开发、维护和部署。最终目标是最大限度地降低系统的生命周期成本并最大限度地提高程序员的生产力。 架构设计之道 Change is the only constant. 如果说软件开发中有不变的真理，那就是变化不可避免。为了应付变化。软件工程师总结出许多原则，比如封装变化，针对接口编程，依赖抽象，最少知识原则等等。 记得很久以前开始思考软件的设计的时候，最常犯的错误就是，为了减少代码量而设计，特别是滥用继承，导致代码僵化重构后面对变化更加痛苦，如果当时了解了种种原则，生活肯定容易许多。 本书用了三分之一的篇幅来讲这些原则。包括用于指导如何设计类的 SOLID 原则，和指导如何设计组件的六个原则。这里类不单单是面向对象的概念，而是更加泛化地指一组函数和数据，也称为模块（module）。 而组件指的是，指的是独立的可部署单元，是模块的集合。比如 java 中的 jar，ruby 的 gem。 SOLID 原则指导类的设计应该容忍变化、易于理解。组件原则指导组件的内聚和组件间的耦合，其实也是 java 的分包原则。 组件内聚： 重用发布等价原则（Release/Reuse Equivalency Principle） 共同封闭原则（Common Closure Principle） 共同重用原则（Common Reuse Principle） 组件耦合： 无环依赖原则 ADP（Acycle Dependencies Principle） 稳定依赖原则 SDP（Stable Dependencies Principle） 稳定抽象原则 SAP（Stable Abstractions Principle） 篇幅所限就不进行解释了，作者还介绍了两个度量组件稳定性和抽象性的量： 不稳定性：\(I = F_{out}/(F_{in}+F_{out})\)，\(F_{in}\) 传入依赖；\(F_{out}\) 传出依赖。依赖关系应该，高 I 值依赖低 I 值。 抽象性：\(A = N_a/N_c\)，\(N_c\) 类的数目；\(N_a\) 抽象类或接口的数目。 作者还聊了编程范式的发展，他的观点也挺有意思：编程的发展，是一个添加限制的过程。三种范式都从我们身上夺走了一些东西。每一种都限制了我们编写代码的方式。 结构化编程，对直接控制转移进行了限制 面向对象编程，对间接控制转移进行了控制 函数式编程，对变量分配进行了限制 面向对象最核心的就是增强了多态，引入多态后，高级函数依赖于低级函数的接口，而不是具体实现。把对具体实现的依赖分离出来。低级的实现，可以被独立部署更替。这就是依赖反转。对架构师来说提供了使用多态性来获得对系统中每个源代码依赖关系的绝对控制的能力。 另外，Dijkstra 《Go To Statement Considered Harmful》的故事也值得了解一下。 清晰架构 Every problem in computer science can be solved with a layer of indirection (besides the problem of too many layers of indirection) 清晰架构，在 2011 年作者的博客就有提到这个名词 Clean Architecture，另一篇引用比较多的博文 The Clean Architecture 写于 12 年，内容所讲的就是本书的清晰架构。 所以，清晰架构不是什么新东西，他是六边形架构(Hexagonal Architecture)的一个变体，基于以往多种架构的发展和归纳，提出来的一个新架构模型。 传统的分层架构是垂直形式的层次架构，清晰架构是由外往内的圆环状层次架构： 这样架构有几个特点： 一个核心 抽象性往内递增 外层依赖内层 层与层之间通过接口与适配器进行交流 框架、数据库、UI 等都是细节 核心的实体指的就是领域内的关键业务逻辑，最不可能发生变化的部分，比如苹果总是往下掉；保险总有承保人、投保人、被保险人、受益人；还贷的等额本息、等额本金算法。关键业务逻辑应该是系统中最独立和可重用的代码。 第二层是用例，用例是应用程序的业务逻辑。用例关注与输入数据并产生输出数据，但用例对象不应去关心数据如何传递给用户或其他任何组件。 接着是接口适配层，将实体和用例转化为更适用外层使用的形式。将外部数据转化为用例或实体使用的内部形式。这一层最强大的工具就是依赖倒置，以 MVP 为例，更新界面的时候，控制流的方向 Presenter -&amp;gt; UI，而依赖关系却是 UI 依赖于 Presenter 层（实现了 Presenter 层相应的 View 接口） UI 在外层这个理所当然了，名字本身就说明了它直接和用户打交道，而且 UI 是掌控在设计和产品手里，越不能控制的东西越要小心其变化。 传统的分层结构，数据库总是处于最底层，但其中数据才是关键，数据库不是。关系型数据库只不过是把数据按 b+ 树这样的结构存储起来，然后通过 SQL 来操作数据。我们也可以使用文件存储数据，甚至可以脱离硬盘直接在内存里面用数组、链表、树、图等数据结构组织我们的数据，毕竟内存价格越来越便宜了（五年一个取样，就可以无视近几年 PC 内存的涨幅了😆）。其中关键的点就是推迟决定，我们很难在初期对我们的数据使用场景做个准确的预测，数据库作为细节隔离在核心系统外，以后因为性能规模等等问题变动数据库更加容易。 但框架呢？框架总是鼓励我们和应用程序紧密的耦合在一起，它提供一种模式，只要我们服从这个模式就能获得极大的便利，代价就是这个框架和我们应用的各个层次紧密地耦合在一起。这有什么风险？其一，框架也许可以帮助您完成应用程序的一些早期功能。 但是随着产品的成熟，它可能会超出框架的功能。其二，框架可能会朝着你没有帮助的方向发展，你甚至可能会发现 API 消失、改变了，因为控制权在作者而不是在你手上。其三就是总有新框架出来，你可能希望切换到更新更好的框架。 最近一个朋友维护老项目遇到一个 android-async-http 的问题向我求助，android-async-http！！！这个不是我一开始做 Android 项目用的网络库吗？起码也是 11、12 年的事了。虽然是个不错的库但也不维护几年了吧。遇到底层的 Bug 别提有多棘手了，而且维护的价值已不大，投入太多时间又觉得亏，最终只能用一些额外的措施把它掩盖过去。 但分离框架，谈何容易呢。这几年写的 App，数据层也从手写 Dao 到 greenDao 到 DBFlow 再到现在的 Room。Room 虽然有官方加持，但以谷歌的尿性被弃用也是随时的事。如果引入 Room，最内层的 Entity 就得使用 Room 的注解便会对 Room 的依赖。如果要分离呢，就需要在数据层也定义一套 Entity，层层之间的数据传递还需要做转换，把核心的 Entity 转换为数据层的 Entity，这样做就很清晰架构了1，但是有必要吗？ 架构的矛盾在于，我们不应该预见抽象的必要性。知道 YAGNI（You aren’t gonna need it）吗？这是个饱含智慧的理念：“你不需要它。”。因为过度工程往往比不够工程化更糟糕。典型的移动应用程序与典型的企业应用程序有很大不同。它要小得多，并且通常需要快速交付。记住架构是演化的，不能简单地在项目的开始时决定实施哪些边界以及忽略哪些边界。相反，随着系统的发展，边界会慢慢变的清晰，你会关注到它，再权衡实施和忽略的成本，在实施成本低于忽略成本的拐点时做出决定。 不能手里有个锤子看到什么都是钉子。就像当初学设计模式一样，学了之后又要让你忘掉它。 Android-CleanArchitecture 就是这样的设计，但在 Kotlin 版已经不用了。 &amp;#8617;</summary></entry><entry><title type="html">新年新博客</title><link href="http://dourok.info/2018/01/02/new-year-new-blog/" rel="alternate" type="text/html" title="新年新博客" /><published>2018-01-02T00:00:00+00:00</published><updated>2018-09-27T09:26:14+00:00</updated><id>http://dourok.info/2018/01/02/new-year-new-blog</id><content type="html" xml:base="http://dourok.info/2018/01/02/new-year-new-blog/">&lt;h3 id=&quot;迁移-jekyll&quot;&gt;迁移 Jekyll&lt;/h3&gt;
&lt;p&gt;网站在 18 年元旦终于重做的差不多了，五年前买的主机在去年 12 月过期了，促使我终于将拖了一年多的 Jekyll 迁移计划落地。Ruhoh 从 14 年就再没有更新，虽然用起来没什么大问题，但总有一些小毛病，比如生成速度过慢(Jekyll 也不快，15 款高配 MBP 全站生成都大概要 10秒)，实时预览的功能也没有 Jekyll 的增长式构建那么强大。作为一个小众的静态博客生成系统基本也没什么生态，迁移到主流的 Jekyll 是迟早的事，只不过我对 Ruhoh 做了不少定制，迁移要在 Jekyll 这边重新实现一遍挺费时间的。&lt;/p&gt;

&lt;p&gt;最大的问题就是笔记系统，Jekyll 和 Ruhoh 都支持页面资源的归类和管理，Jekyll 中叫 Collection，Ruhoh 叫 Resource。Jekyll 的理念是所有 Collection 生而平等，但有些 Collection 更平等。比如其他 Collection 就不像 Posts 那样自带标签汇总。Ruhoh 的 Resource 才是真平等，通过插件扩展的能力也更强大当然也更繁琐。之前的笔记和日记就是通过自定义 Resource 实现的。&lt;/p&gt;

&lt;p&gt;用 Jekyll 实现笔记系统我没有对 Collection 进行扩展，通过配置来实现部分功能，舍弃了父类别也能生成页面的功能。笔记的树结构 json 通过 generator 插件实现。标签归纳也得自己实现。固定连接反而是最简单的，一条配置搞定：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scope:
  type: &quot;notes&quot;
values:
  layout: &quot;note&quot;
  permalink: &quot;/:collection/:path/&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外还有一些自定义插件，比如 LaTeX， &lt;code&gt;Kramdown&lt;/code&gt; 是默认支持的。至于 &lt;a href=&quot;https://graphviz.gitlab.io/&quot;&gt;graphviz&lt;/a&gt;，我发现 Kramdown 的定制比 Redcarpet 麻烦。最后还是决定用自定义 liquid &lt;a href=&quot;https://jekyllrb.com/docs/plugins/#tags&quot;&gt;tags&lt;/a&gt; 实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% graphviz %}
digraph G {
	subgraph cluster_0 {
	....

	start [shape=Mdiamond];
	end [shape=Msquare];
}
{% endgraphviz %}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;graphviz&quot; data-graph=&quot;
digraph G {

	subgraph cluster_0 {
		style=filled;
		color=lightgrey;
		node [style=filled,color=white];
		a0 -&amp;gt; a1 -&amp;gt; a2 -&amp;gt; a3;
		label = &amp;quot;process #1&amp;quot;;
	}

	subgraph cluster_1 {
		node [style=filled];
		b0 -&amp;gt; b1 -&amp;gt; b2 -&amp;gt; b3;
		label = &amp;quot;process #2&amp;quot;;
		color=blue
	}
	start -&amp;gt; a0;
	start -&amp;gt; b0;
	a1 -&amp;gt; b3;
	b2 -&amp;gt; a3;
	a3 -&amp;gt; a0;
	a3 -&amp;gt; end;
	b3 -&amp;gt; end;

	start [shape=Mdiamond];
	end [shape=Msquare];
}
&quot;&gt;
        &lt;/div&gt;

&lt;p&gt;还有一个就是&lt;a href=&quot;https://github.com/douo/douo.github.com/blob/develop/_plugins/ruhoh_jekyll.rb&quot;&gt;迁移脚本&lt;/a&gt;，首先将文章的文件名转换为符合 Jekyll 规则。 Ruhoh 用的模板语言是 &lt;a href=&quot;https://mustache.github.io&quot;&gt;Mustache&lt;/a&gt;，眼看 Mustache 被微信小程序选用了有机会火了，又被我放弃了…… Markdown 引擎是 &lt;a href=&quot;https://github.com/vmg/redcarpet&quot;&gt;Redcarpet&lt;/a&gt;，Jekyll 则是 &lt;a href=&quot;https://shopify.github.io/liquid/&quot;&gt;Liquid&lt;/a&gt; 和 &lt;a href=&quot;https://kramdown.gettalong.org/&quot;&gt;Kramdown&lt;/a&gt;，所以还需对内文做一些转换和过滤。还是最重要的一点是将页面引用的本地资源进行整理。&lt;/p&gt;

&lt;h3 id=&quot;resource-管理&quot;&gt;Resource 管理&lt;/h3&gt;

&lt;p&gt;对页面资源进行管理是由来已久的想法。要求每篇文章（Document）的都有一个独立的资源目录，然后目录内的文件都可以在正文内通过相对路径访问。这样就不用再将所有资源都挤在 media 文件夹，还得用一个`` 来获取 media 的相对路径。实现是通过一个 &lt;a href=&quot;https://github.com/douo/douo.github.com/blob/develop/_plugins/resource_generator.rb&quot;&gt;generator&lt;/a&gt; 将资源拷贝到相应路径实现的，最终的目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_res
├── notes
│   ├── Programming
│   │   ├── Android
│   │   │   └── loader
│   │   │       ├── Loader.png
│   │   │       └── loader_event.png
│   ├── Reading
│   │   └── computer-systems-a-programmer-s-perspective
│   │       └── CSAPP
│   │           ├── CSAPP-5.10&amp;amp;5.11.png
│   │           ├── CSAPP-5.5&amp;amp;5.6.png
│   │           ├── address_translation.png
│   │           └── process_address_space.png
└── posts
    ├── 2013-08-16-the-pain-of-note
    │   └── note_system_review.js
    ├── 2013-10-22-the-pain-of-note-2
    │   └── categories.org
    ├── 2016-12-24-hierarchy-fragment-pager-adapter
    │   ├── b_aa_ba_ca.png
    │   ├── b_ba_baa_baaa.png
    │   └── b_ba_ca.png
    ├── 2017-10-20-lambda-in-android
    │   └── desugar_diagram.png
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;命令行接口&quot;&gt;命令行接口&lt;/h3&gt;

&lt;p&gt;Jekyll 是没有对资源进行操作的命令行接口的，这点还是 Ruhoh 做得比较好，可以对每个 Resource/Collection 的命令行接口进行定制。&lt;/p&gt;

&lt;p&gt;Jekyll 要可以通过 Commands 插件实现命令行接口。见 &lt;a href=&quot;https://github.com/douo/douo.github.com/tree/develop/jekyll-moon&quot;&gt;jekyll-moon&lt;/a&gt;，目前扩展了 &lt;code&gt;create&lt;/code&gt; 命令，实现了创建 post 和 note。接下来还需要实现创建资源目录、内文搜索，list 等。&lt;/p&gt;

&lt;h3 id=&quot;主题&quot;&gt;主题&lt;/h3&gt;

&lt;p&gt;后台的事说得差不多，接下来说说前台。主题和网站结构重新做了设计。基于 &lt;a href=&quot;http://materializecss.com/&quot;&gt;Materialize&lt;/a&gt; 主题也是像素级照搬。不过也算实现了一直很想做的 MD 设计。&lt;/p&gt;

&lt;p&gt;用了 ES6 和 Sass，Jekyll 默认支持 Sass 处理器。至于 Es6 用的是 jekyll-babel，babel-source（5.8.35） 快两年没更新了，看来 Rubier 还是喜好 coffee-script 多一些。&lt;/p&gt;

&lt;h3 id=&quot;搜索&quot;&gt;搜索&lt;/h3&gt;

&lt;p&gt;网站最大的突破是终于有了能用的搜索，基于 &lt;a href=&quot;https://lunrjs.com/&quot;&gt;Lunr&lt;/a&gt; 实现的浏览器端的搜索。目前只对标题和标签进行索引。&lt;/p&gt;

&lt;p&gt;Lunr 默认不支持中文，它的建立索引的过程是先通过分词器进行处理，&lt;a href=&quot;https://github.com/olivernn/lunr.js/blob/master/lib/tokenizer.js&quot;&gt;tokenizer.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;再对每个 token，通过 pipeline 进行处理，默认有三个 pipeline：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;builder.pipeline.add(
    lunr.trimmer, // 过来所以非 \W 字符，中文会在这里被过滤掉
    lunr.stopWordFilter, // 过滤停止词
    lunr.stemmer // 返回词干
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;考虑到中文分词的复杂性，所以我将分词放在 Ruby 端处理，找了一遍没有找到特别合适的分词器，主要是不想有 native extension，在 travis-ci 上部署不方便。所以目前只是单纯将中文与英文分隔开而已，见 &lt;a href=&quot;https://github.com/douo/douo.github.com/blob/develop/_plugins/index_generator.rb&quot;&gt;index_generator.rb&lt;/a&gt;。要搜索中文最好还是得手动加上通配符，Lunr 的搜索用法可参考 &lt;a href=&quot;https://lunrjs.com/guides/searching.html&quot;&gt;Searching : Lunr&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;自动部署&quot;&gt;自动部署&lt;/h3&gt;
&lt;p&gt;GitHub 虽然支持 Jekyll，但我加了不少 Jekyll 插件，想直接用 GitHub 来部署是不可能的。不过也不是没有办法的，比如用免费的持续集成服务 &lt;a href=&quot;https://travis-ci.org&quot;&gt;travis-ci.org&lt;/a&gt; 来实现持续部署，Travis 支持部署到 GitHub Page，几行配置搞定：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deploy:
  provider: pages
  skip_cleanup: true
  github_token: $GITHUB_TOKEN # Set in travis-ci.org dashboard
  local_dir: ${TRAVIS_BUILD_DIR}/_site
  target_branch: master
  on:
    branch: develop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jekyll 的持续集成可参考官方文档 &lt;a href=&quot;https://jekyllrb.com/docs/continuous-integration/travis-ci/&quot;&gt;Travis CI | jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;支持-https-的免费主机&quot;&gt;支持 HTTPS 的免费主机&lt;/h3&gt;

&lt;p&gt;到这里基本实现了 &lt;code&gt;push&lt;/code&gt; 后自动构建并部署到 https://douo.github.com 由 GitHub 来免费托管，也可以绑定自己的域名2，一切看起来都很美好。但要为自己的域名添加免费 HTTPS 支持就没那么容易。幸好 &lt;a href=&quot;https://www.netlify.com/&quot;&gt;Netlify&lt;/a&gt; 恰能提供这样的服务，并支持绑定免费的 &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let’s Encrypt - Free SSL/TLS Certificates&lt;/a&gt; 证书，具体可参考：&lt;a href=&quot;https://jaeger.itscoder.com/web/2017/08/30/github-page-https&quot;&gt;GitHub Page 博客自定义域名添加 HTTPS 支持&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;更新&quot;&gt;更新&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;2018年05月29日，引入 webpack 管理前端资源，使用 &lt;a href=&quot;https://github.com/clenemt/clenemt.com.git&quot;&gt;clenemt&lt;/a&gt; 的配置。&lt;/li&gt;
  &lt;li&gt;2018年09月27日，github 已经支持&lt;a href=&quot;https://blog.github.com/2018-05-01-github-pages-custom-domains-https/&quot;&gt;自定义域名 https&lt;/a&gt;，所以从 netlify 迁回 github 了，netlify 速度实在太慢。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="jekyll" /><category term="ruhoh" /><category term="lunr" /><summary type="html">迁移 Jekyll 网站在 18 年元旦终于重做的差不多了，五年前买的主机在去年 12 月过期了，促使我终于将拖了一年多的 Jekyll 迁移计划落地。Ruhoh 从 14 年就再没有更新，虽然用起来没什么大问题，但总有一些小毛病，比如生成速度过慢(Jekyll 也不快，15 款高配 MBP 全站生成都大概要 10秒)，实时预览的功能也没有 Jekyll 的增长式构建那么强大。作为一个小众的静态博客生成系统基本也没什么生态，迁移到主流的 Jekyll 是迟早的事，只不过我对 Ruhoh 做了不少定制，迁移要在 Jekyll 这边重新实现一遍挺费时间的。 最大的问题就是笔记系统，Jekyll 和 Ruhoh 都支持页面资源的归类和管理，Jekyll 中叫 Collection，Ruhoh 叫 Resource。Jekyll 的理念是所有 Collection 生而平等，但有些 Collection 更平等。比如其他 Collection 就不像 Posts 那样自带标签汇总。Ruhoh 的 Resource 才是真平等，通过插件扩展的能力也更强大当然也更繁琐。之前的笔记和日记就是通过自定义 Resource 实现的。 用 Jekyll 实现笔记系统我没有对 Collection 进行扩展，通过配置来实现部分功能，舍弃了父类别也能生成页面的功能。笔记的树结构 json 通过 generator 插件实现。标签归纳也得自己实现。固定连接反而是最简单的，一条配置搞定： scope: type: &quot;notes&quot; values: layout: &quot;note&quot; permalink: &quot;/:collection/:path/&quot; 另外还有一些自定义插件，比如 LaTeX， Kramdown 是默认支持的。至于 graphviz，我发现 Kramdown 的定制比 Redcarpet 麻烦。最后还是决定用自定义 liquid tags 实现。 {% graphviz %} digraph G { subgraph cluster_0 { .... start [shape=Mdiamond]; end [shape=Msquare]; } {% endgraphviz %} 还有一个就是迁移脚本，首先将文章的文件名转换为符合 Jekyll 规则。 Ruhoh 用的模板语言是 Mustache，眼看 Mustache 被微信小程序选用了有机会火了，又被我放弃了…… Markdown 引擎是 Redcarpet，Jekyll 则是 Liquid 和 Kramdown，所以还需对内文做一些转换和过滤。还是最重要的一点是将页面引用的本地资源进行整理。 Resource 管理 对页面资源进行管理是由来已久的想法。要求每篇文章（Document）的都有一个独立的资源目录，然后目录内的文件都可以在正文内通过相对路径访问。这样就不用再将所有资源都挤在 media 文件夹，还得用一个`` 来获取 media 的相对路径。实现是通过一个 generator 将资源拷贝到相应路径实现的，最终的目录结构如下： _res ├── notes │   ├── Programming │   │   ├── Android │   │   │   └── loader │   │   │   ├── Loader.png │   │   │   └── loader_event.png │   ├── Reading │   │   └── computer-systems-a-programmer-s-perspective │   │   └── CSAPP │   │   ├── CSAPP-5.10&amp;amp;5.11.png │   │   ├── CSAPP-5.5&amp;amp;5.6.png │   │   ├── address_translation.png │   │   └── process_address_space.png └── posts ├── 2013-08-16-the-pain-of-note │   └── note_system_review.js ├── 2013-10-22-the-pain-of-note-2 │   └── categories.org ├── 2016-12-24-hierarchy-fragment-pager-adapter │   ├── b_aa_ba_ca.png │   ├── b_ba_baa_baaa.png │   └── b_ba_ca.png ├── 2017-10-20-lambda-in-android │   └── desugar_diagram.png 命令行接口 Jekyll 是没有对资源进行操作的命令行接口的，这点还是 Ruhoh 做得比较好，可以对每个 Resource/Collection 的命令行接口进行定制。 Jekyll 要可以通过 Commands 插件实现命令行接口。见 jekyll-moon，目前扩展了 create 命令，实现了创建 post 和 note。接下来还需要实现创建资源目录、内文搜索，list 等。 主题 后台的事说得差不多，接下来说说前台。主题和网站结构重新做了设计。基于 Materialize 主题也是像素级照搬。不过也算实现了一直很想做的 MD 设计。 用了 ES6 和 Sass，Jekyll 默认支持 Sass 处理器。至于 Es6 用的是 jekyll-babel，babel-source（5.8.35） 快两年没更新了，看来 Rubier 还是喜好 coffee-script 多一些。 搜索 网站最大的突破是终于有了能用的搜索，基于 Lunr 实现的浏览器端的搜索。目前只对标题和标签进行索引。 Lunr 默认不支持中文，它的建立索引的过程是先通过分词器进行处理，tokenizer.js 再对每个 token，通过 pipeline 进行处理，默认有三个 pipeline： builder.pipeline.add( lunr.trimmer, // 过来所以非 \W 字符，中文会在这里被过滤掉 lunr.stopWordFilter, // 过滤停止词 lunr.stemmer // 返回词干 ) 考虑到中文分词的复杂性，所以我将分词放在 Ruby 端处理，找了一遍没有找到特别合适的分词器，主要是不想有 native extension，在 travis-ci 上部署不方便。所以目前只是单纯将中文与英文分隔开而已，见 index_generator.rb。要搜索中文最好还是得手动加上通配符，Lunr 的搜索用法可参考 Searching : Lunr 自动部署 GitHub 虽然支持 Jekyll，但我加了不少 Jekyll 插件，想直接用 GitHub 来部署是不可能的。不过也不是没有办法的，比如用免费的持续集成服务 travis-ci.org 来实现持续部署，Travis 支持部署到 GitHub Page，几行配置搞定： deploy: provider: pages skip_cleanup: true github_token: $GITHUB_TOKEN # Set in travis-ci.org dashboard local_dir: ${TRAVIS_BUILD_DIR}/_site target_branch: master on: branch: develop Jekyll 的持续集成可参考官方文档 Travis CI | jekyll 支持 HTTPS 的免费主机 到这里基本实现了 push 后自动构建并部署到 https://douo.github.com 由 GitHub 来免费托管，也可以绑定自己的域名2，一切看起来都很美好。但要为自己的域名添加免费 HTTPS 支持就没那么容易。幸好 Netlify 恰能提供这样的服务，并支持绑定免费的 Let’s Encrypt - Free SSL/TLS Certificates 证书，具体可参考：GitHub Page 博客自定义域名添加 HTTPS 支持。 更新 2018年05月29日，引入 webpack 管理前端资源，使用 clenemt 的配置。 2018年09月27日，github 已经支持自定义域名 https，所以从 netlify 迁回 github 了，netlify 速度实在太慢。</summary></entry><entry><title type="html">Lambda in Android</title><link href="http://dourok.info/2017/10/20/lambda-in-android/" rel="alternate" type="text/html" title="Lambda in Android" /><published>2017-10-20T00:00:00+00:00</published><updated>2017-11-30T15:56:47+00:00</updated><id>http://dourok.info/2017/10/20/lambda-in-android</id><content type="html" xml:base="http://dourok.info/2017/10/20/lambda-in-android/">&lt;h3 id=&quot;android-如何实现支持-lambda-表达式&quot;&gt;Android 如何实现支持 lambda 表达式&lt;/h3&gt;

&lt;p&gt;lambda 表达式是 java 8 新引入的语言特性，使用了通过 java 7 新引入的字节码指令 invokedynamic 来实现的（参考 &lt;a href=&quot;http://wiki.jvmlangsummit.com/images/7/7b/Goetz-jvmls-lambda.pdf&quot;&gt;Goetz-jvmls-lambda.pdf&lt;/a&gt;）。但在 dalvik 中并没有相应的指令，所以直接将 java 8 的字节码翻译为 dalvik 字节码目前是是不可行的。不过从 java lambda 的实现上来讲，实际上就是内部匿名类的语法糖。&lt;/p&gt;

&lt;p&gt;既然是语法糖，那就是一个代码转换的事，把这个过程抽离出来另外实现，就可以在低版本的 jdk 中实现对 lambda 的支持。&lt;a href=&quot;https://github.com/orfjackal/retrolambda&quot;&gt;retrolambda&lt;/a&gt;，就是在字节码层面实现这个转换。retrolambda 的具体实现是基于 java 8 对 lambda 的底层实现来做的。在编译时，java 主要为当前类（lambda 表达式所在的类）生成一个方法，方法体（method body）就是 lambda body，这个方法称为 desugar 方法。运行时，第一次执行到这条 lambda 语句的时候，invokedynamic 调用引导方法（BSM），引导方法生成一个实现了具体函数式接口（Functional Interface，只有一个抽象方法的接口）的 VM 匿名类，这个类主要用于捕获 lambda 所需要的变量。第二步，把这个对象的构造函数和 invokdynamic 绑定起来，最后调用这个构造函数返回这个匿名类的实例，也就是所谓的 lambda object（以后再执行这条 invokedynamic 指令就是直接调用构造函数返回实例了）。调用的时候，再把接口方法需要的参数和捕获的变量传递给 desugar 方法来完成 lambda 的应用（可参考&lt;a href=&quot;http://dourok.info/2017/10/08/understanding-invokedynamic&quot;&gt;理解 invokedynamic&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;retrolambda 的做法是，源文件先用 java 8 编译，lambda body 转换为当前类的 desugar 方法编译器已经处理好了。接着解析编译后的 class 文件，遇到一条 invokedynamic 指令，就模仿它调用它的引导方法（&lt;a href=&quot;https://github.com/orfjackal/retrolambda/blob/master/retrolambda/src/main/java/net/orfjackal/retrolambda/lambdas/LambdaReifier.java#L26&quot;&gt;LambdaReifier.reifyLambdaClass&lt;/a&gt;），把引导方法生成的匿名类作为当前类的匿名类保存下来，接下来还会对这些类再做一些变换，包括用单例优化无状态的 lambda 对象，将构造函数替换为工厂方法（&lt;a href=&quot;https://github.com/orfjackal/retrolambda/blob/master/retrolambda/src/main/java/net/orfjackal/retrolambda/lambdas/BackportLambdaClass.java#L60&quot;&gt;BackportLambdaClass#visitEnd&lt;/a&gt;）。最后把 invokedynamic 替换为对该匿名类的实例化语句，就是这样把 invokedynamic 替换为等价的兼容代码。不过， retrolambda 的实现依赖于 java 对 lambda 的具体实现，后续的 java 版本不用匿名类了，那么 retrolambda 也就不能用了。&lt;/p&gt;

&lt;p&gt;在 Android Studio 3.0 之前，要在基于 java 的 Android 开发中使用 lambda 表达一般都是用 retrolambda 来转换为 dex 能处理的字节码来实现的（就不提夭折的 Jack 了）。 不过 Android Studio 3.0 后，IDE 已经支持实现这个转换了，简称 desugar。具体如何开启可参看官方文档：&lt;a href=&quot;https://developer.android.com/studio/write/java8-support.html&quot;&gt;Use Java 8 language features&lt;/a&gt;。IDE 的 desugar 过程比 retrolamda 的主要区别就是时机不同，原理上大致是一样的，IDE 的实现可见 &lt;a href=&quot;https://android.googlesource.com/platform/external/desugar/+/master/java/com/google/devtools/build/android/desugar/LambdaDesugaring.java#394&quot;&gt;LambdaDesugaring#visitInvokeDynamicInsn&lt;/a&gt;。 retrolambda 只能对当前项目进行转换，IDE 是在转换为 dex 之前做的转换，也就是说 IDE 还支持第三方用 java 8 编译的库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;desugar_diagram.png&quot; alt=&quot;android 构建流程图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;原图见 &lt;a href=&quot;https://sites.google.com/a/android.com/tools/tech-docs/new-build-system/build-workflow&quot;&gt;Build Workflow - Android Studio Project Site&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;总之，Android 对 lambda 的实现与 java 8 并未太大区别，最主要的区别 java 8 的匿名类在运行时生成，而 Android 是在编译时生成（这样还可以避免了对 serializable lambda 的特殊对待）。&lt;/p&gt;

&lt;h3 id=&quot;lambda-表达式&quot;&gt;lambda 表达式&lt;/h3&gt;

&lt;p&gt;lambda 表达式在 java 中就是用于创建函数式接口实例（lambda object）的表达式，lambda 的实际使用中，主要将其分为两种类型，其一，无状态的（stateless） lambda 表达式，指的就是没有自由变量的 lambda 表达式。相对的，另一类就是有自由变量的 lambda 表达式。&lt;/p&gt;

&lt;p&gt;什么是自由变量，把一道 lambda 表达式从其上下文抽离出来看一下：&lt;code&gt;L1 = s -&amp;gt; Integer.valueOf(s)&lt;/code&gt;。表达式中的两个量 Integer 和 s，Integer 是常量，而 s 在参数列表中声明了（类型省略），这里称 s 是一个绑定变量，所有量都是确定的，所以 L1 就是无状态的 lambda 表达式（可以认为它的调用不会产生任何副作用）。&lt;/p&gt;

&lt;p&gt;另外一个例子：&lt;code&gt;() -&amp;gt; System.out.println(Arrays.toString(args))&lt;/code&gt;。&lt;code&gt;args&lt;/code&gt; 是什么？脱离了上下文就无法确定了，如果在上下文中看，就很清楚 &lt;code&gt;args&lt;/code&gt; 是什么了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    Runnable r = () -&amp;gt; System.out.println(Arrays.toString(args));
    r.run();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;args&lt;/code&gt; 在这里就是自由变量。要对 lambda 表达式求值前所有自由变量都是得已知的，java 中所有自由变量都必须在编译期确认（另外一种不同的实现可参考 &lt;a href=&quot;http://groovy-lang.org/closures.html#_delegate_of_a_closure&quot;&gt;Groovy&lt;/a&gt;），为自由变量确定值的过程称为变量捕获（capturing），把变量捕获后和 lambda 表达式绑定在一起的结构就是闭包（closure），lambda 对象实例就是一个闭包。java 中就是通过匿名类来存放这些捕获这些变量，而且是以 final 引用的形式，所以更应该说是值而不是变量。&lt;/p&gt;

&lt;p&gt;先看一下最简单的无状态 lambda：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class LambdaTest {
    public void testStateless() {
        Runnable r = (() -&amp;gt; System.out.println(&quot;pure&quot;));
        r.run();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译后再反编译，可以看到，变成了两个类（可以在 &lt;code&gt;build/intermediates/transforms/desugar&lt;/code&gt; 中找到）：&lt;/p&gt;

&lt;p&gt;LambdaTest:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class LambdaTest {
    public void testStateless() {
        Runnable r = LambdaTest$$Lambda$0.$instance;
        r.run();
    }
    
    static void lambda$testPure$0$LambdaTest(){
        System.out.println(&quot;pure&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LambdaTest$$Lambda$0:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final class LambdaTest$$Lambda$0 implements Runnable {
  static final Runnable $instance = new LambdaTest$$Lambda$0();

  private LambdaTest$$Lambda$0() {
  }

  public void run() {
    LambdaTest.lambda$testPure$0$LambdaTest();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lambda body 变成了 LambdaTest 中的一个静态方法，也就是所谓的 desugar 方法，另外还生成了一个类 &lt;code&gt;LambdaTest$$Lambda$0&lt;/code&gt; 实现了函数式接口，在其实现方法里再去调用 desugar 方法，无状态 lambda 对象不需要保存额外的参数，这里用单例进行优化。&lt;/p&gt;

&lt;p&gt;如果捕获了变量，以局部变量和形式参数为例，无论是局部变量还是上下文方法的形式参数，它们的值和类型都是编译时确定的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void capturingLocal(String strp) {
    String str = &quot;lexical&quot;;
    Runnable r = () -&amp;gt; System.out.println(str + strp);
    r.run();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LambdaTest$$Lambda$1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final class LambdaTest$$Lambda$1 implements Runnable {
  private final String arg$1;
  private final String arg$2;

  LambdaTest$$Lambda$1(String var1, String var2) {
    this.arg$1 = var1;
    this.arg$2 = var2;
  }

  public void run() {
    LambdaTest.lambda$capturingLocal$1$LambdaTest(this.arg$1, this.arg$2);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原先的 lambda 表达式赋值语句变成了 &lt;code&gt;Runnable r = new LambdaTest$$Lambda$1(str, strp)&lt;/code&gt;，自由变量都通过 lambda 对象构造器进行捕获并保存起来，对 lambda 求值的时候再传递给 desugar 方法，这里 Runnable 的方法没有形式参数，如果有形式参数的话，这些捕获的变量会排在形式参数后面再传递给 desugar 方法。&lt;/p&gt;

&lt;p&gt;如果在 lambda 中引用了对象字段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private String stri = &quot;instance&quot;;
public void capturingInstance() {
    Runnable r = () -&amp;gt; System.out.println(stri);
    r.run();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LambdaTest$$Lambda$4:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final class LambdaTest$$Lambda$4 implements Runnable {
  private final LambdaTest arg$1;

  LambdaTest$$Lambda$4(LambdaTest var1) {
    this.arg$1 = var1;
  }

  public void run() {
    this.arg$1.lambda$capturingInstance$4$LambdaTest();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 lambda 对象保存了上下文类的引用，无论是实例变量还是实例方法，实际上都有一个隐性的接收者就是 &lt;code&gt;this&lt;/code&gt;，当然也可以显性的声明，在 lambda body 中的 &lt;code&gt;this&lt;/code&gt; 引用指向的就是其上下文的类，而不是 lambda 对象（与匿名类的区别）。在这里 lambda 表达捕获的变量就是实例变量的接收者 &lt;code&gt;this&lt;/code&gt; 而不是实例变量本身。而且可以看到 lambda 的 desugar 方法变成了实例方法，用这种方式，lambda body 几乎不用做任何转换只需照搬进方法体就行。还包括对 &lt;code&gt;super&lt;/code&gt; 的处理，lambda 对象无法捕获 super，只能通过调用 this 的实例方法来实现对 super 的调用，可见用 desugar 方法来实现是十分便利的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 的捕获，对于 Android 开发来说特别要注意，&lt;strong&gt;在 Activity 中使用 lambda 表达式的话，意味着会通过 final 引用的形象将当前 Activity 实例传递到外部去，稍不注意便会引起泄露。一个显而易见的技巧，将实例字段赋值给局部变量，就不会捕获 this 引用了。当然对于生命周期相关的对象来说还是不安全的，比如 View。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;方法引用&quot;&gt;方法引用&lt;/h3&gt;

&lt;p&gt;方法引用基本可以当成是 lambda 表达式的一个特例，方法引用都可以用相应的 lambda 表达式来代替，有一个例外就是带有类型参数方法的函数式接口，能用方法引用但不能用 lambda 表达式，见 &lt;a href=&quot;https://stackoverflow.com/questions/22588518/lambda-expression-and-generic-method&quot;&gt;java - Lambda Expression and generic method - Stack Overflow&lt;/a&gt;。方法引用也分为捕获与非捕获，对于无须捕获接的方法引用主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;静态方法&lt;/li&gt;
  &lt;li&gt;构造器&lt;/li&gt;
  &lt;li&gt;未绑定的实例方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;什么是未绑定的实例方法？方法引用语法可以大致认为是&lt;code&gt;接收者::方法名&lt;/code&gt;这样的形式，方法可以是实例方法或者是静态方法，当方法是实例方法而接收者是类引用时，这时接收者就是一个未绑定的接收者：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list.filter(String::isEmpty)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;isEmpty&lt;/code&gt; 是实例方法，而接收者是类引用，在这里接收者在运行会被替换为被替换为 list 内的元素，等价于这样的 lambda 表达式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list.filter(s -&amp;gt; s.isEmpty())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意非绑定的实例方法引用是有二义性的，java 根据方法的声明去推定 &lt;code&gt;isEmpty&lt;/code&gt; 是实例方法还是静态方法，以下面的类为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class C{
   public static boolean isEmpty(C c);
   public boolean isEmpty();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上面的方法声明两个方法对于表达式 &lt;code&gt;list.filter(C::isEmpty)&lt;/code&gt; 来说都是合法的，java 也就无法推断出这里是指哪个方法引用，所以编译器报错。&lt;/p&gt;

&lt;p&gt;需要捕获的方法引用，也就是已绑定实例的方法引用，包括实例方法，内部类（数组）的构造器，super 方法。接收者就是闭包所要捕获的变量。但要注意一点方法引用是没有隐式声明的 &lt;code&gt;this&lt;/code&gt; 引用的。比如下面两个方法，从语义上来说是等价的，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void capturingInstance() {
    Predicate&amp;lt;String&amp;gt; c = s -&amp;gt; stri.equals(s);
}

public void capturingIntanceMethod() {
    Predicate&amp;lt;String&amp;gt; c = stri::equals;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是他们捕获的引用却不一样，&lt;strong&gt;上文可知 lambda 表达式捕获的是隐式声明的 &lt;code&gt;this&lt;/code&gt;，而方法引用捕获的却是直接接收者&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final class LambdaTest$$Lambda$8 implements Predicate {
  private final String arg$1;

  private LambdaTest$$Lambda$8(String var1) {
    this.arg$1 = var1;
  }

  static Predicate get$Lambda(String var0) {
    return new LambdaTest$$Lambda$8(var0);
  }

  public boolean test(Object var1) {
    return this.arg$1.equals((String)var1);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一点，使用方法引用，因为方法已经是现成的，大部分情况就没必要重新生成一个 desugar 方法。&lt;/p&gt;

&lt;p&gt;但有例外，super 和可变参数，需要一个桥接方法。对于 super 来说，lambda 对象是无法不会当前类的 super 引用的，所以需要借由当前类的实例方法来实现对 super 的引用。&lt;/p&gt;

&lt;p&gt;接收者也可以是表达式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Predicate&amp;lt;String&amp;gt; c = (stri.equals(&quot;abc&quot;) ? &quot;abc&quot; : &quot;bcd&quot;)::equals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里捕获的是表达式求值的结果而不是表达式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以对于 Activity 来说，要格外注意下面几种情况可能导致引用泄露&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;this&lt;/code&gt; 关键字的方法引用&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;super&lt;/code&gt; 关键字的方法引用&lt;/li&gt;
  &lt;li&gt;非静态内部类的构造器引用&lt;/li&gt;
  &lt;li&gt;Activity 或其实例变量可变参数方法引用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可参考  &lt;a href=&quot;http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html&quot;&gt;Translation of Lambda Expressions&lt;/a&gt;。&lt;/p&gt;</content><author><name></name></author><summary type="html">Android 如何实现支持 lambda 表达式 lambda 表达式是 java 8 新引入的语言特性，使用了通过 java 7 新引入的字节码指令 invokedynamic 来实现的（参考 Goetz-jvmls-lambda.pdf）。但在 dalvik 中并没有相应的指令，所以直接将 java 8 的字节码翻译为 dalvik 字节码目前是是不可行的。不过从 java lambda 的实现上来讲，实际上就是内部匿名类的语法糖。 既然是语法糖，那就是一个代码转换的事，把这个过程抽离出来另外实现，就可以在低版本的 jdk 中实现对 lambda 的支持。retrolambda，就是在字节码层面实现这个转换。retrolambda 的具体实现是基于 java 8 对 lambda 的底层实现来做的。在编译时，java 主要为当前类（lambda 表达式所在的类）生成一个方法，方法体（method body）就是 lambda body，这个方法称为 desugar 方法。运行时，第一次执行到这条 lambda 语句的时候，invokedynamic 调用引导方法（BSM），引导方法生成一个实现了具体函数式接口（Functional Interface，只有一个抽象方法的接口）的 VM 匿名类，这个类主要用于捕获 lambda 所需要的变量。第二步，把这个对象的构造函数和 invokdynamic 绑定起来，最后调用这个构造函数返回这个匿名类的实例，也就是所谓的 lambda object（以后再执行这条 invokedynamic 指令就是直接调用构造函数返回实例了）。调用的时候，再把接口方法需要的参数和捕获的变量传递给 desugar 方法来完成 lambda 的应用（可参考理解 invokedynamic）。 retrolambda 的做法是，源文件先用 java 8 编译，lambda body 转换为当前类的 desugar 方法编译器已经处理好了。接着解析编译后的 class 文件，遇到一条 invokedynamic 指令，就模仿它调用它的引导方法（LambdaReifier.reifyLambdaClass），把引导方法生成的匿名类作为当前类的匿名类保存下来，接下来还会对这些类再做一些变换，包括用单例优化无状态的 lambda 对象，将构造函数替换为工厂方法（BackportLambdaClass#visitEnd）。最后把 invokedynamic 替换为对该匿名类的实例化语句，就是这样把 invokedynamic 替换为等价的兼容代码。不过， retrolambda 的实现依赖于 java 对 lambda 的具体实现，后续的 java 版本不用匿名类了，那么 retrolambda 也就不能用了。 在 Android Studio 3.0 之前，要在基于 java 的 Android 开发中使用 lambda 表达一般都是用 retrolambda 来转换为 dex 能处理的字节码来实现的（就不提夭折的 Jack 了）。 不过 Android Studio 3.0 后，IDE 已经支持实现这个转换了，简称 desugar。具体如何开启可参看官方文档：Use Java 8 language features。IDE 的 desugar 过程比 retrolamda 的主要区别就是时机不同，原理上大致是一样的，IDE 的实现可见 LambdaDesugaring#visitInvokeDynamicInsn。 retrolambda 只能对当前项目进行转换，IDE 是在转换为 dex 之前做的转换，也就是说 IDE 还支持第三方用 java 8 编译的库。 原图见 Build Workflow - Android Studio Project Site 总之，Android 对 lambda 的实现与 java 8 并未太大区别，最主要的区别 java 8 的匿名类在运行时生成，而 Android 是在编译时生成（这样还可以避免了对 serializable lambda 的特殊对待）。 lambda 表达式 lambda 表达式在 java 中就是用于创建函数式接口实例（lambda object）的表达式，lambda 的实际使用中，主要将其分为两种类型，其一，无状态的（stateless） lambda 表达式，指的就是没有自由变量的 lambda 表达式。相对的，另一类就是有自由变量的 lambda 表达式。 什么是自由变量，把一道 lambda 表达式从其上下文抽离出来看一下：L1 = s -&amp;gt; Integer.valueOf(s)。表达式中的两个量 Integer 和 s，Integer 是常量，而 s 在参数列表中声明了（类型省略），这里称 s 是一个绑定变量，所有量都是确定的，所以 L1 就是无状态的 lambda 表达式（可以认为它的调用不会产生任何副作用）。 另外一个例子：() -&amp;gt; System.out.println(Arrays.toString(args))。args 是什么？脱离了上下文就无法确定了，如果在上下文中看，就很清楚 args 是什么了： public static void main(String[] args) { Runnable r = () -&amp;gt; System.out.println(Arrays.toString(args)); r.run(); } args 在这里就是自由变量。要对 lambda 表达式求值前所有自由变量都是得已知的，java 中所有自由变量都必须在编译期确认（另外一种不同的实现可参考 Groovy），为自由变量确定值的过程称为变量捕获（capturing），把变量捕获后和 lambda 表达式绑定在一起的结构就是闭包（closure），lambda 对象实例就是一个闭包。java 中就是通过匿名类来存放这些捕获这些变量，而且是以 final 引用的形式，所以更应该说是值而不是变量。 先看一下最简单的无状态 lambda： public class LambdaTest { public void testStateless() { Runnable r = (() -&amp;gt; System.out.println(&quot;pure&quot;)); r.run(); } } 编译后再反编译，可以看到，变成了两个类（可以在 build/intermediates/transforms/desugar 中找到）： LambdaTest: public class LambdaTest { public void testStateless() { Runnable r = LambdaTest$$Lambda$0.$instance; r.run(); } static void lambda$testPure$0$LambdaTest(){ System.out.println(&quot;pure&quot;); } } LambdaTest$$Lambda$0: final class LambdaTest$$Lambda$0 implements Runnable { static final Runnable $instance = new LambdaTest$$Lambda$0(); private LambdaTest$$Lambda$0() { } public void run() { LambdaTest.lambda$testPure$0$LambdaTest(); } } lambda body 变成了 LambdaTest 中的一个静态方法，也就是所谓的 desugar 方法，另外还生成了一个类 LambdaTest$$Lambda$0 实现了函数式接口，在其实现方法里再去调用 desugar 方法，无状态 lambda 对象不需要保存额外的参数，这里用单例进行优化。 如果捕获了变量，以局部变量和形式参数为例，无论是局部变量还是上下文方法的形式参数，它们的值和类型都是编译时确定的： public void capturingLocal(String strp) { String str = &quot;lexical&quot;; Runnable r = () -&amp;gt; System.out.println(str + strp); r.run(); } LambdaTest$$Lambda$1： final class LambdaTest$$Lambda$1 implements Runnable { private final String arg$1; private final String arg$2; LambdaTest$$Lambda$1(String var1, String var2) { this.arg$1 = var1; this.arg$2 = var2; } public void run() { LambdaTest.lambda$capturingLocal$1$LambdaTest(this.arg$1, this.arg$2); } } 原先的 lambda 表达式赋值语句变成了 Runnable r = new LambdaTest$$Lambda$1(str, strp)，自由变量都通过 lambda 对象构造器进行捕获并保存起来，对 lambda 求值的时候再传递给 desugar 方法，这里 Runnable 的方法没有形式参数，如果有形式参数的话，这些捕获的变量会排在形式参数后面再传递给 desugar 方法。 如果在 lambda 中引用了对象字段： private String stri = &quot;instance&quot;; public void capturingInstance() { Runnable r = () -&amp;gt; System.out.println(stri); r.run(); } LambdaTest$$Lambda$4: final class LambdaTest$$Lambda$4 implements Runnable { private final LambdaTest arg$1; LambdaTest$$Lambda$4(LambdaTest var1) { this.arg$1 = var1; } public void run() { this.arg$1.lambda$capturingInstance$4$LambdaTest(); } } 可以看到 lambda 对象保存了上下文类的引用，无论是实例变量还是实例方法，实际上都有一个隐性的接收者就是 this，当然也可以显性的声明，在 lambda body 中的 this 引用指向的就是其上下文的类，而不是 lambda 对象（与匿名类的区别）。在这里 lambda 表达捕获的变量就是实例变量的接收者 this 而不是实例变量本身。而且可以看到 lambda 的 desugar 方法变成了实例方法，用这种方式，lambda body 几乎不用做任何转换只需照搬进方法体就行。还包括对 super 的处理，lambda 对象无法捕获 super，只能通过调用 this 的实例方法来实现对 super 的调用，可见用 desugar 方法来实现是十分便利的。 this 的捕获，对于 Android 开发来说特别要注意，在 Activity 中使用 lambda 表达式的话，意味着会通过 final 引用的形象将当前 Activity 实例传递到外部去，稍不注意便会引起泄露。一个显而易见的技巧，将实例字段赋值给局部变量，就不会捕获 this 引用了。当然对于生命周期相关的对象来说还是不安全的，比如 View。 方法引用 方法引用基本可以当成是 lambda 表达式的一个特例，方法引用都可以用相应的 lambda 表达式来代替，有一个例外就是带有类型参数方法的函数式接口，能用方法引用但不能用 lambda 表达式，见 java - Lambda Expression and generic method - Stack Overflow。方法引用也分为捕获与非捕获，对于无须捕获接的方法引用主要有： 静态方法 构造器 未绑定的实例方法 什么是未绑定的实例方法？方法引用语法可以大致认为是接收者::方法名这样的形式，方法可以是实例方法或者是静态方法，当方法是实例方法而接收者是类引用时，这时接收者就是一个未绑定的接收者： list.filter(String::isEmpty) isEmpty 是实例方法，而接收者是类引用，在这里接收者在运行会被替换为被替换为 list 内的元素，等价于这样的 lambda 表达式： list.filter(s -&amp;gt; s.isEmpty()) 注意非绑定的实例方法引用是有二义性的，java 根据方法的声明去推定 isEmpty 是实例方法还是静态方法，以下面的类为例： public class C{ public static boolean isEmpty(C c); public boolean isEmpty(); } 如上面的方法声明两个方法对于表达式 list.filter(C::isEmpty) 来说都是合法的，java 也就无法推断出这里是指哪个方法引用，所以编译器报错。 需要捕获的方法引用，也就是已绑定实例的方法引用，包括实例方法，内部类（数组）的构造器，super 方法。接收者就是闭包所要捕获的变量。但要注意一点方法引用是没有隐式声明的 this 引用的。比如下面两个方法，从语义上来说是等价的， public void capturingInstance() { Predicate&amp;lt;String&amp;gt; c = s -&amp;gt; stri.equals(s); } public void capturingIntanceMethod() { Predicate&amp;lt;String&amp;gt; c = stri::equals; } 但是他们捕获的引用却不一样，上文可知 lambda 表达式捕获的是隐式声明的 this，而方法引用捕获的却是直接接收者： final class LambdaTest$$Lambda$8 implements Predicate { private final String arg$1; private LambdaTest$$Lambda$8(String var1) { this.arg$1 = var1; } static Predicate get$Lambda(String var0) { return new LambdaTest$$Lambda$8(var0); } public boolean test(Object var1) { return this.arg$1.equals((String)var1); } } 还有一点，使用方法引用，因为方法已经是现成的，大部分情况就没必要重新生成一个 desugar 方法。 但有例外，super 和可变参数，需要一个桥接方法。对于 super 来说，lambda 对象是无法不会当前类的 super 引用的，所以需要借由当前类的实例方法来实现对 super 的引用。 接收者也可以是表达式： Predicate&amp;lt;String&amp;gt; c = (stri.equals(&quot;abc&quot;) ? &quot;abc&quot; : &quot;bcd&quot;)::equals; 在这里捕获的是表达式求值的结果而不是表达式。 所以对于 Activity 来说，要格外注意下面几种情况可能导致引用泄露： this 关键字的方法引用 super 关键字的方法引用 非静态内部类的构造器引用 Activity 或其实例变量可变参数方法引用 可参考 Translation of Lambda Expressions。</summary></entry><entry><title type="html">理解 invokedynamic</title><link href="http://dourok.info/2017/10/08/understanding-invokedynamic/" rel="alternate" type="text/html" title="理解 invokedynamic" /><published>2017-10-08T00:00:00+00:00</published><updated>2017-11-30T15:56:47+00:00</updated><id>http://dourok.info/2017/10/08/understanding-invokedynamic</id><content type="html" xml:base="http://dourok.info/2017/10/08/understanding-invokedynamic/">&lt;p&gt;inDy（invokedynamic）是 java 7 引入的一条新的虚拟机指令，这是自 1.0 以来第一次引入新的虚拟机指令。到了 java 8 这条指令才第一次在 java 应用，用在 lambda 表达式中。 indy 与其他 invoke 指令不同的是它允许由应用级的代码来决定方法解析。所谓应用级的代码其实是一个方法，在这里这个方法被称为引导方法（Bootstrap Method），简称 BSM。BSM 返回一个 CallSite（调用点） 对象，这个对象就和 inDy 链接在一起了。以后再执行这条 inDy 指令都不会创建新的 CallSite 对象。CallSite 就是一个 MethodHandle（方法句柄）的 holder。方法句柄指向一个调用点真正执行的方法。&lt;/p&gt;

&lt;p&gt;理解 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/invoke/MethodHandle.html&quot;&gt;MethodHandle&lt;/a&gt;（方法句柄）的一种方式就是将其视为以安全、现代的方式来实现反射的核心功能。&lt;/p&gt;

&lt;p&gt;一个 java 方法的实体有四个构成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;方法名&lt;/li&gt;
  &lt;li&gt;签名–参数列表和返回值&lt;/li&gt;
  &lt;li&gt;定义方法的类&lt;/li&gt;
  &lt;li&gt;方法体（代码）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同一个类中，方法名相同，签名不同，JVM 会视为不同的方法，不过在 Java 中只支持签名的参数列表部分，也就是重载多态。一次方法调用，除了要方法的实体外，还要调用者（caller）和接收者（receiver），调用者也就是方法调用语句所在的类。接收者是一个对象，每个方法调用都要一个接收者，它可以是隐藏的（this），也可以是类方法，比如： &lt;code&gt;String.valueOf&lt;/code&gt;，类也是 Class 的一个实例。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/invoke/MethodType.html&quot;&gt;MethodType&lt;/a&gt; 表示方法签名。&lt;/p&gt;

&lt;p&gt;用 MethodHandle 实现的方法调用的示例如下，可以看到方法的四个构成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object rcvr = &quot;a&quot;;
try {
    MethodType mt = MethodType.methodType(int.class); // 方法签名
    MethodHandles.Lookup l = MethodHandles.lookup(); // 调用者，也就是当前类。调用者决定有没有权限能访问到方法
    MethodHandle mh = l.findVirtual(rcvr.getClass(), &quot;hashCode&quot;, mt); //分别是定义方法的类，方法名，签名

    int ret;
    try {
        ret = (int)mh.invoke(rcvr); // 代码，第一个参数就是接收者
        System.out.println(ret);
    } catch (Throwable t) {
        t.printStackTrace();
    }
} catch (IllegalArgumentException | NoSuchMethodException | SecurityException e) {
    e.printStackTrace();
} catch (IllegalAccessException x) {
    x.printStackTrace();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细可参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.infoq.com/articles/Invokedynamic-Javas-secret-weapon&quot;&gt;Invokedynamic - Java’s Secret Weapon&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;和译文 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/28124632&quot;&gt;Invokedynamic：Java的秘密武器 - 知乎专栏&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java8-lambda-表达式&quot;&gt;java8 lambda 表达式&lt;/h3&gt;

&lt;p&gt;lambda 表达式 是怎么使用 inDy 呢？以一段简单的代码为例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class LambdaTest {
    public static void main(String[] args) {
        Runnable r = () -&amp;gt; System.out.println(Arrays.toString(args));
        r.run();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用 &lt;code&gt;javap -v -p LambdaTest&lt;/code&gt; 查看字节码，可以发现寥寥几行 java 代码生成的字节码却不少，单单常量池常量就有 66 个之多。输出见 &lt;a href=&quot;https://gist.github.com/douo/05550163c8f40ffa38232084b800332c&quot;&gt;LambdaTest.class&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;可以发现多出了一个新方法，方法体就是 lambda 体（lambda body），转换为源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static void lambda$main$0(java.lang.String[] args){
    System.out.println(Arrays.toString(args));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要看一下 main 方法，并没有直接调用上面的方法，而是出现一条 inDy 指令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=2, args_size=1
         0: aload_0
         1: invokedynamic #2,  0              // InvokeDynamic #0:run:([Ljava/lang/String;)Ljava/lang/Runnable;
         6: astore_1
         7: aload_1
         8: invokeinterface #3,  1            // InterfaceMethod java/lang/Runnable.run:()V
        13: return
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 inDy 指向一个类型为 [CONSTANT_InvokeDynamic_info][] 的常量项 &lt;code&gt;#2&lt;/code&gt;，另外 &lt;code&gt;0&lt;/code&gt; 是预留参数，暂时没有作用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#2 = InvokeDynamic      #0:#30         // #0:run:([Ljava/lang/String;)Ljava/lang/Runnable;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;#0&lt;/code&gt; 表示在 &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.21&quot;&gt;Bootstrap methods 表&lt;/a&gt;中的索引：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BootstrapMethods:
  0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;
    Method arguments:
      #28 ()V
      #29 invokestatic com/company/LambdaTest.lambda$main$0:([Ljava/lang/String;)V
      #28 ()V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;#30&lt;/code&gt; 则是一个 [CONSTANT_NameAndType_info][]，表示方法名和方法类型（返回值和参数列表），这个会作为参数传递给 BSM。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#30 = NameAndType        #43:#44        // run:([Ljava/lang/String;)Ljava/lang/Runnable;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再看回表中的第 0 项，&lt;code&gt;#27&lt;/code&gt; 是一个 [CONSTANT_MethodHandle_info][]，实际上是个 MethodHandle（方法句柄）对象，这个句柄指向的就是 BSM 方法。在这里就是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java.lang.invoke.LambdaMetafactory.metafactory(MethodHandles.Lookup,String,MethodType,MethodType,MethodHandle,MethodType)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BSM 前三个参数是固定的，后面还可以附加任意数量的参数，但是参数的类型是有限制的，参数类型只能是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;String&lt;/li&gt;
  &lt;li&gt;Class&lt;/li&gt;
  &lt;li&gt;int&lt;/li&gt;
  &lt;li&gt;long&lt;/li&gt;
  &lt;li&gt;float&lt;/li&gt;
  &lt;li&gt;double&lt;/li&gt;
  &lt;li&gt;MethodHandle&lt;/li&gt;
  &lt;li&gt;MethodType&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LambdaMetafactory.metafactory 带多三个参数，这些的参数的值由 &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.21&quot;&gt;Bootstrap methods 表&lt;/a&gt; 提供：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Method arguments:
  #25 ()V
  #26 invokestatic com/company/LambdaTest.lambda$main$0:()V
  #25 ()V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;inDy 所需要的数据大概就是这些，可参考 &lt;a href=&quot;http://blog.csdn.net/zxhoo/article/details/38387141&quot;&gt;Java8学习笔记（2） – InvokeDynamic指令 - CSDN博客&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;indy-运行时&quot;&gt;inDy 运行时&lt;/h4&gt;

&lt;p&gt;每一个 inDy 指令都称为 Dynamic Call Site(动态调用点)，根据 jvm 规范所说的，inDy 可以分为两步，这两步部分代码代码是在 java 层的，给 &lt;code&gt;metafactory&lt;/code&gt; 方法设断点可以看到一些行为。&lt;/p&gt;

&lt;p&gt;第一步 inDy 需要一个 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/invoke/CallSite.html&quot;&gt;CallSite&lt;/a&gt;（调用点对象），CallSite 是由 BSM 返回的，所以这一步就是调用 BSM 方法。代码可参考：&lt;a href=&quot;https://github.com/dmlloyd/openjdk/blob/92e8b3df00eddf6c661a8a2c52339d50a358d472/jdk/src/java.base/share/classes/java/lang/invoke/CallSite.java#L300&quot;&gt;java.lang.invoke.CallSite#makeSite&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;调用 BSM 方法可以看作 invokevirtual 指令执行一个 invoke 方法，方法签名如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;invoke:(MethodHandle,Lookup,String,MethodType,/*其他附加静态参数*/)CallSite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前四个参数是固定的，被依次压入操作栈里&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;MethodHandle，实际上这个方法句柄就是指向 BSM&lt;/li&gt;
  &lt;li&gt;Lookup, 也就是调用者，是 Indy 指令所在的类的上下文，可以通过 &lt;code&gt;Lookup#lookupClass()&lt;/code&gt;获取这个类&lt;/li&gt;
  &lt;li&gt;name ，lambda 所实现的方法名，也就是&lt;code&gt;&quot;run&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;invokedType，调用点的方法签名，这里是 &lt;code&gt;methodType(Runnable.class,String[].class)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来就是附加参数，这些参数是灵活的，由&lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.21&quot;&gt;Bootstrap methods 表&lt;/a&gt;提供，这里分别是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;samMethodType，其实就是 Runnable.run 的描述符: &lt;code&gt;methodType(void.class)&lt;/code&gt;。sam 就 single public abstract method 的缩写&lt;/li&gt;
  &lt;li&gt;implMethod: 编译器给生成的 desugar 方法，是一个 MethodHandle：&lt;code&gt;caller.findStatic(LambdaTest.class,&quot;lambda$main$0&quot;,methodType(void.class))&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;instantiatedMethodType:  Runnable.run 运行时的描述符，如果方法泛型的，那这个类型可能不一样。这里是 &lt;code&gt;methodType(void.class)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面说的固定其实应该是指 inDy 传递的实参类型是固定的，BSM 形参声明可以是随意，保证 BSM 能被调用就行，比如说 Lookup 声明为 Object 不影响调用。&lt;/p&gt;

&lt;p&gt;接下来就是执行 &lt;code&gt;LambdaMetafactory.metafactory&lt;/code&gt; 方法了，它会创建一个匿名类，这个类是通过 &lt;a href=&quot;http://asm.ow2.org/&quot;&gt;ASM&lt;/a&gt; 编织字节码在内存中生成的，然后直接通过 unsafe 直接加载而不会写到文件里。不过可以通过下面的虚拟机参数让它运行的时候输出到文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-Djdk.internal.lambda.dumpProxyClasses=&amp;lt;path&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个类是根据 lambda 的特点生成的，输出后可以看到，在这个例子中是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import java.lang.invoke.LambdaForm.Hidden;

// $FF: synthetic class
final class LambdaTest$$Lambda$1 implements Runnable {
    private final String[] arg$1;

    private LambdaTest$$Lambda$1(String[] var1) {
        this.arg$1 = var1;
    }

    private static Runnable get$Lambda(String[] var0) {
        return new LambdaTest$$Lambda$1(var0);
    }

    @Hidden
    public void run() {
        LambdaTest.lambda$main$0(this.arg$1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就是创建一个 CallSite，绑定一个 MethodHandle，指向的方法其实就是生成的类中的静态方法 &lt;code&gt;LambdaTest$$Lambda$1.get$Lambda(String[])Runnable&lt;/code&gt;。然后把调用点对象返回，到这里 BSM 方法执行完毕。&lt;/p&gt;

&lt;p&gt;更详细的可参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/0251fef3211c&quot;&gt;浅谈Lambda Expression - 简书&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27159693&quot;&gt;[Java] 关于OpenJDK对Java 8 lambda表达式的运行时实现的查看方式 - 知乎专栏&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二步，就是执行这个方法句柄了，这个过程就像 &lt;code&gt;invokevirtual&lt;/code&gt; 指令执行 &lt;code&gt;MethodHandle#invokeExact&lt;/code&gt; 一样，&lt;/p&gt;

&lt;p&gt;加上 inDy 上面那一条 &lt;code&gt;aload_0&lt;/code&gt; 指令，这是操作数栈有两个分别是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;args[]，lambda 里面调用了 main 方法的参数&lt;/li&gt;
  &lt;li&gt;调用点对象（CallSite），实际上是方法句柄。如果是 CostantCallSite 的时候，inDy 会直接跟他的方法句柄链接。见代码：&lt;a href=&quot;https://github.com/dmlloyd/openjdk/blob/77d7cb3ad9efc4edeaae7cc46e3b4a98ea617679/jdk/src/java.base/share/classes/java/lang/invoke/MethodHandleNatives.java#L255&quot;&gt;MethodHandleNatives.java#L255&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;传入 args，执行方法，返回一个 Runnable 对象，压入栈顶。到这里 inDy 就执行完毕。&lt;/p&gt;

&lt;p&gt;接下来的指令就很好理解，&lt;code&gt;astore_1&lt;/code&gt; 把栈顶的 Runnable 对象放到局部变量表的槽位1，也是变量 &lt;code&gt;r&lt;/code&gt;。剩下的就是再拿出来调用 &lt;code&gt;run&lt;/code&gt; 方法。&lt;/p&gt;

&lt;h3 id=&quot;groovy&quot;&gt;Groovy&lt;/h3&gt;

&lt;p&gt;接下来看一下 groovy 是如何使用 inDy 指令的。先复习一遍 groovy 的方法派发。&lt;/p&gt;

&lt;p&gt;每当 Groovy 调用一个方法时，它不会直接调用它，而是要求一个中间层来代替它。 中间层通过钩子方法允许我们更改方法调用的行为。这个中间层就是 MOP（meta object proctol），MOP 主要承载的类就是 &lt;a href=&quot;https://github.com/groovy/groovy-core/blob/master/src/main/groovy/lang/MetaClass.java&quot;&gt;MetaClass&lt;/a&gt; 。一个简化版的 MOP 主要有这些方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;invokeMethod(String methodName, Object args)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;methodMissing(String name, Object arguments)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;getProperty(String propertyName)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;setProperty(String propertyName, Object newValue)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;propertyMissing(String name)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以大致认为在 Groovy 中的每个方法和属性访问调用都会转化上面的方法调用。而这些方法可以在运行时通过重写修改它的默认行为，MOP 作为方法派发的中心枢纽为 Groovy 提供了非常灵活的动态编程的能力。&lt;/p&gt;

&lt;p&gt;现在来看一下一段简短的 groovy 代码，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Test{
  int a = 0;
  static void main(args){
      Test wtf = new Test()
      wtf.a
      wtf.doSomething()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code&gt;groovyc -indy Test.groovy&lt;/code&gt; 把它编译成字节码。 &lt;code&gt;indy&lt;/code&gt; 选项的意思就是启用  invokedynamic 支持。&lt;/p&gt;

&lt;p&gt;看一下编译后的 main 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(java.lang.String...);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC, ACC_VARARGS
    Code:
      stack=1, locals=2, args_size=1
         0: ldc           #2                  // class Test
         2: invokedynamic #44,  0             // InvokeDynamic #0:init:(Ljava/lang/Class;)Ljava/lang/Object;
         7: invokedynamic #50,  0             // InvokeDynamic #1:cast:(Ljava/lang/Object;)LTest;
        12: astore_1
        13: aload_1
        14: pop
        15: aload_1
        16: invokedynamic #56,  0             // InvokeDynamic #2:getProperty:(LTest;)Ljava/lang/Object;
        21: pop
        22: aload_1
        23: invokedynamic #61,  0             // InvokeDynamic #3:invoke:(LTest;)Ljava/lang/Object;
        28: pop
        29: return
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到一共有 4 条 inDy 指令，包括构造函数，访问成员变量，和不存在的方法调用都是 通过 invokedynamic 实现的。&lt;/p&gt;

&lt;p&gt;再看一下引导方法表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BootstrapMethods:
  0: #38 invokestatic org/codehaus/groovy/vmplugin/v7/IndyInterface.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;I)Ljava/lang/invoke/CallSite;
    Method arguments:
      #39 &amp;lt;init&amp;gt;
      #40 0
  1: #38 invokestatic org/codehaus/groovy/vmplugin/v7/IndyInterface.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;I)Ljava/lang/invoke/CallSite;
    Method arguments:
      #46 ()
      #40 0
  2: #38 invokestatic org/codehaus/groovy/vmplugin/v7/IndyInterface.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;I)Ljava/lang/invoke/CallSite;
    Method arguments:
      #51 a
      #52 4
  3: #38 invokestatic org/codehaus/groovy/vmplugin/v7/IndyInterface.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;I)Ljava/lang/invoke/CallSite;
    Method arguments:
      #58 doSomething
      #40 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现所有 inDy 指令的引导方法都是 &lt;a href=&quot;https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/vmplugin/v7/IndyInterface.java#L132&quot;&gt;IndyInterface.bootstrap&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以方法调用的 inDy 指令为例，它的方法名称是 “invoke”，方法签名是 &lt;code&gt;methodType(Object.class,Test.class)&lt;/code&gt;，BSM 方法还附带两个参数分别是实际的方法名：&lt;code&gt;&quot;doSomething&quot;&lt;/code&gt; 和一个标志：0&lt;/p&gt;

&lt;p&gt;BSM 方法最终调用的是 &lt;code&gt;realBootstrap&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static CallSite realBootstrap(Lookup caller, String name, int callID, MethodType type, boolean safe, boolean thisCall, boolean spreadCall) {
    MutableCallSite mc = new MutableCallSite(type); //这里是 MutableCallSite，lambda 表达式用的是 ConstantCallSite
    MethodHandle mh = makeFallBack(mc,caller.lookupClass(),name,callID,type,safe,thisCall,spreadCall);
    mc.setTarget(mh);
    return mc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要的代码是调用 &lt;code&gt;makeFallBack&lt;/code&gt; 来获取一个临时的 MethodHandle。因为在第一步 groovy 无法确定接收者（receiver），也是就是 invoke 方法的第一个实参（Test 实例），必须要在第二步确定 CallSite 后才会传递过来。所以方法解析要放在第二步。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected static MethodHandle makeFallBack(MutableCallSite mc, Class&amp;lt;?&amp;gt; sender, String name, int callID, MethodType type, boolean safeNavigation, boolean thisCall, boolean spreadCall) {
    MethodHandle mh = MethodHandles.insertArguments(SELECT_METHOD, 0, mc, sender, name, callID, safeNavigation, thisCall, spreadCall, /*dummy receiver:*/ 1); //MethodHandle(Object.class,Object[].class)
    mh =    mh.asCollector(Object[].class, type.parameterCount()).
            asType(type);
    return mh;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 fallback 方法其实就是 &lt;code&gt;selectMethod&lt;/code&gt;。&lt;code&gt;insertArguments&lt;/code&gt; 在这里主要做了一个柯里化的操作，因为&lt;code&gt;selectMethod&lt;/code&gt; 的方法签名是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;methodType(Object.class, MutableCallSite.class, Class.class, String.class, int.class, Boolean.class, Boolean.class, Boolean.class, Object.class, Object[].class)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而 inDy 要求的方法签名却是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;methodType(Object.class,Test.class)。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以得经过 &lt;code&gt;insertArguments&lt;/code&gt; 的变换，把确定的值填充进去，用最后的数组参数来接收 inDy 传递的参数。这样这个方法就能够被 inDy 调用了。第一步创建 CallSite 到这里就结束。&lt;/p&gt;

&lt;p&gt;第二步，就是 selectMethod 方法的调用，这时候 groovy 已经知道方法的接收者 &lt;code&gt;arguments[0]&lt;/code&gt;，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static Object selectMethod(MutableCallSite callSite, Class sender, String methodName, int callID, Boolean safeNavigation, Boolean thisCall, Boolean spreadCall, Object dummyReceiver, Object[] arguments) throws Throwable {
    Selector selector = Selector.getSelector(callSite, sender, methodName, callID, safeNavigation, thisCall, spreadCall, arguments); 
    selector.setCallSiteTarget();

    MethodHandle call = selector.handle.asSpreader(Object[].class, arguments.length);
    call = call.asType(MethodType.methodType(Object.class,Object[].class));
    return call.invokeExact(arguments);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先创建一个方法解析器，在这里是 &lt;code&gt;MethodSelector&lt;/code&gt;。接着调用 &lt;code&gt;setCallSiteTarget()&lt;/code&gt;，这个方法就是用来解析实际的方法。具体的过程还是很复杂的，所以也没法说清楚，大体来说就是确定接收者的 &lt;code&gt;MetaClass&lt;/code&gt;，决定这个方法是实际的方法，还是交给 &lt;code&gt;MetaClass&lt;/code&gt; 的钩子方法，然后就是创建这个方法的 MethodHandle，然后把这个 MethodHandle 的签名转化为要求的签名。这时 selecor.handle 就是最终调用的方法句柄了。接下来就是最终的方法调用了，到这里 inDy 指令就执行完毕了。&lt;/p&gt;

&lt;p&gt;还有一个方法值得留意：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void doCallSiteTargetSet() {
    if (!cache) {
        if (LOG_ENABLED) LOG.info(&quot;call site stays uncached&quot;);
    } else {
        callSite.setTarget(handle);
        if (LOG_ENABLED) LOG.info(&quot;call site target set, preparing outside invocation&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也是为什么用 &lt;code&gt;MutableCallSite&lt;/code&gt; 的原因，如果编译器认为这个方法是可以缓存，那么就会把这个 CallSite 绑定到实际的 MethodHandle，后续的调用就不用再重新解析了。&lt;/p&gt;

&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;

&lt;p&gt;没有相关经验，inDy 还是很不好理解的，学习了 java 8 和 groovy 对 inDy 的应用才有一点大致的认识，文中如果有什么错误，还请帮忙指出。&lt;/p&gt;</content><author><name></name></author><category term="coder" /><category term="JVM" /><category term="groovy" /><category term="java" /><category term="lambda" /><category term="invokedynamic" /><summary type="html">inDy（invokedynamic）是 java 7 引入的一条新的虚拟机指令，这是自 1.0 以来第一次引入新的虚拟机指令。到了 java 8 这条指令才第一次在 java 应用，用在 lambda 表达式中。 indy 与其他 invoke 指令不同的是它允许由应用级的代码来决定方法解析。所谓应用级的代码其实是一个方法，在这里这个方法被称为引导方法（Bootstrap Method），简称 BSM。BSM 返回一个 CallSite（调用点） 对象，这个对象就和 inDy 链接在一起了。以后再执行这条 inDy 指令都不会创建新的 CallSite 对象。CallSite 就是一个 MethodHandle（方法句柄）的 holder。方法句柄指向一个调用点真正执行的方法。 理解 MethodHandle（方法句柄）的一种方式就是将其视为以安全、现代的方式来实现反射的核心功能。 一个 java 方法的实体有四个构成： 方法名 签名–参数列表和返回值 定义方法的类 方法体（代码） 同一个类中，方法名相同，签名不同，JVM 会视为不同的方法，不过在 Java 中只支持签名的参数列表部分，也就是重载多态。一次方法调用，除了要方法的实体外，还要调用者（caller）和接收者（receiver），调用者也就是方法调用语句所在的类。接收者是一个对象，每个方法调用都要一个接收者，它可以是隐藏的（this），也可以是类方法，比如： String.valueOf，类也是 Class 的一个实例。 MethodType 表示方法签名。 用 MethodHandle 实现的方法调用的示例如下，可以看到方法的四个构成： Object rcvr = &quot;a&quot;; try { MethodType mt = MethodType.methodType(int.class); // 方法签名 MethodHandles.Lookup l = MethodHandles.lookup(); // 调用者，也就是当前类。调用者决定有没有权限能访问到方法 MethodHandle mh = l.findVirtual(rcvr.getClass(), &quot;hashCode&quot;, mt); //分别是定义方法的类，方法名，签名 int ret; try { ret = (int)mh.invoke(rcvr); // 代码，第一个参数就是接收者 System.out.println(ret); } catch (Throwable t) { t.printStackTrace(); } } catch (IllegalArgumentException | NoSuchMethodException | SecurityException e) { e.printStackTrace(); } catch (IllegalAccessException x) { x.printStackTrace(); } 详细可参考： Invokedynamic - Java’s Secret Weapon 和译文 Invokedynamic：Java的秘密武器 - 知乎专栏 java8 lambda 表达式 lambda 表达式 是怎么使用 inDy 呢？以一段简单的代码为例 public class LambdaTest { public static void main(String[] args) { Runnable r = () -&amp;gt; System.out.println(Arrays.toString(args)); r.run(); } } 用 javap -v -p LambdaTest 查看字节码，可以发现寥寥几行 java 代码生成的字节码却不少，单单常量池常量就有 66 个之多。输出见 LambdaTest.class。 可以发现多出了一个新方法，方法体就是 lambda 体（lambda body），转换为源码如下： private static void lambda$main$0(java.lang.String[] args){ System.out.println(Arrays.toString(args)); } 主要看一下 main 方法，并没有直接调用上面的方法，而是出现一条 inDy 指令： public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=2, args_size=1 0: aload_0 1: invokedynamic #2, 0 // InvokeDynamic #0:run:([Ljava/lang/String;)Ljava/lang/Runnable; 6: astore_1 7: aload_1 8: invokeinterface #3, 1 // InterfaceMethod java/lang/Runnable.run:()V 13: return 可以看到 inDy 指向一个类型为 [CONSTANT_InvokeDynamic_info][] 的常量项 #2，另外 0 是预留参数，暂时没有作用。 #2 = InvokeDynamic #0:#30 // #0:run:([Ljava/lang/String;)Ljava/lang/Runnable; #0 表示在 Bootstrap methods 表中的索引： BootstrapMethods: 0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; Method arguments: #28 ()V #29 invokestatic com/company/LambdaTest.lambda$main$0:([Ljava/lang/String;)V #28 ()V #30 则是一个 [CONSTANT_NameAndType_info][]，表示方法名和方法类型（返回值和参数列表），这个会作为参数传递给 BSM。 #30 = NameAndType #43:#44 // run:([Ljava/lang/String;)Ljava/lang/Runnable; 再看回表中的第 0 项，#27 是一个 [CONSTANT_MethodHandle_info][]，实际上是个 MethodHandle（方法句柄）对象，这个句柄指向的就是 BSM 方法。在这里就是: java.lang.invoke.LambdaMetafactory.metafactory(MethodHandles.Lookup,String,MethodType,MethodType,MethodHandle,MethodType) BSM 前三个参数是固定的，后面还可以附加任意数量的参数，但是参数的类型是有限制的，参数类型只能是 String Class int long float double MethodHandle MethodType LambdaMetafactory.metafactory 带多三个参数，这些的参数的值由 Bootstrap methods 表 提供： Method arguments: #25 ()V #26 invokestatic com/company/LambdaTest.lambda$main$0:()V #25 ()V inDy 所需要的数据大概就是这些，可参考 Java8学习笔记（2） – InvokeDynamic指令 - CSDN博客 inDy 运行时 每一个 inDy 指令都称为 Dynamic Call Site(动态调用点)，根据 jvm 规范所说的，inDy 可以分为两步，这两步部分代码代码是在 java 层的，给 metafactory 方法设断点可以看到一些行为。 第一步 inDy 需要一个 CallSite（调用点对象），CallSite 是由 BSM 返回的，所以这一步就是调用 BSM 方法。代码可参考：java.lang.invoke.CallSite#makeSite 调用 BSM 方法可以看作 invokevirtual 指令执行一个 invoke 方法，方法签名如下： invoke:(MethodHandle,Lookup,String,MethodType,/*其他附加静态参数*/)CallSite 前四个参数是固定的，被依次压入操作栈里 MethodHandle，实际上这个方法句柄就是指向 BSM Lookup, 也就是调用者，是 Indy 指令所在的类的上下文，可以通过 Lookup#lookupClass()获取这个类 name ，lambda 所实现的方法名，也就是&quot;run&quot; invokedType，调用点的方法签名，这里是 methodType(Runnable.class,String[].class) 接下来就是附加参数，这些参数是灵活的，由Bootstrap methods 表提供，这里分别是： samMethodType，其实就是 Runnable.run 的描述符: methodType(void.class)。sam 就 single public abstract method 的缩写 implMethod: 编译器给生成的 desugar 方法，是一个 MethodHandle：caller.findStatic(LambdaTest.class,&quot;lambda$main$0&quot;,methodType(void.class)) instantiatedMethodType: Runnable.run 运行时的描述符，如果方法泛型的，那这个类型可能不一样。这里是 methodType(void.class) 上面说的固定其实应该是指 inDy 传递的实参类型是固定的，BSM 形参声明可以是随意，保证 BSM 能被调用就行，比如说 Lookup 声明为 Object 不影响调用。 接下来就是执行 LambdaMetafactory.metafactory 方法了，它会创建一个匿名类，这个类是通过 ASM 编织字节码在内存中生成的，然后直接通过 unsafe 直接加载而不会写到文件里。不过可以通过下面的虚拟机参数让它运行的时候输出到文件 -Djdk.internal.lambda.dumpProxyClasses=&amp;lt;path&amp;gt; 这个类是根据 lambda 的特点生成的，输出后可以看到，在这个例子中是这样的： import java.lang.invoke.LambdaForm.Hidden; // $FF: synthetic class final class LambdaTest$$Lambda$1 implements Runnable { private final String[] arg$1; private LambdaTest$$Lambda$1(String[] var1) { this.arg$1 = var1; } private static Runnable get$Lambda(String[] var0) { return new LambdaTest$$Lambda$1(var0); } @Hidden public void run() { LambdaTest.lambda$main$0(this.arg$1); } } 然后就是创建一个 CallSite，绑定一个 MethodHandle，指向的方法其实就是生成的类中的静态方法 LambdaTest$$Lambda$1.get$Lambda(String[])Runnable。然后把调用点对象返回，到这里 BSM 方法执行完毕。 更详细的可参考： 浅谈Lambda Expression - 简书 [Java] 关于OpenJDK对Java 8 lambda表达式的运行时实现的查看方式 - 知乎专栏 第二步，就是执行这个方法句柄了，这个过程就像 invokevirtual 指令执行 MethodHandle#invokeExact 一样， 加上 inDy 上面那一条 aload_0 指令，这是操作数栈有两个分别是： args[]，lambda 里面调用了 main 方法的参数 调用点对象（CallSite），实际上是方法句柄。如果是 CostantCallSite 的时候，inDy 会直接跟他的方法句柄链接。见代码：MethodHandleNatives.java#L255 传入 args，执行方法，返回一个 Runnable 对象，压入栈顶。到这里 inDy 就执行完毕。 接下来的指令就很好理解，astore_1 把栈顶的 Runnable 对象放到局部变量表的槽位1，也是变量 r。剩下的就是再拿出来调用 run 方法。 Groovy 接下来看一下 groovy 是如何使用 inDy 指令的。先复习一遍 groovy 的方法派发。 每当 Groovy 调用一个方法时，它不会直接调用它，而是要求一个中间层来代替它。 中间层通过钩子方法允许我们更改方法调用的行为。这个中间层就是 MOP（meta object proctol），MOP 主要承载的类就是 MetaClass 。一个简化版的 MOP 主要有这些方法： invokeMethod(String methodName, Object args) methodMissing(String name, Object arguments) getProperty(String propertyName) setProperty(String propertyName, Object newValue) propertyMissing(String name) 可以大致认为在 Groovy 中的每个方法和属性访问调用都会转化上面的方法调用。而这些方法可以在运行时通过重写修改它的默认行为，MOP 作为方法派发的中心枢纽为 Groovy 提供了非常灵活的动态编程的能力。 现在来看一下一段简短的 groovy 代码， class Test{ int a = 0; static void main(args){ Test wtf = new Test() wtf.a wtf.doSomething() } } 通过 groovyc -indy Test.groovy 把它编译成字节码。 indy 选项的意思就是启用 invokedynamic 支持。 看一下编译后的 main 方法。 public static void main(java.lang.String...); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC, ACC_VARARGS Code: stack=1, locals=2, args_size=1 0: ldc #2 // class Test 2: invokedynamic #44, 0 // InvokeDynamic #0:init:(Ljava/lang/Class;)Ljava/lang/Object; 7: invokedynamic #50, 0 // InvokeDynamic #1:cast:(Ljava/lang/Object;)LTest; 12: astore_1 13: aload_1 14: pop 15: aload_1 16: invokedynamic #56, 0 // InvokeDynamic #2:getProperty:(LTest;)Ljava/lang/Object; 21: pop 22: aload_1 23: invokedynamic #61, 0 // InvokeDynamic #3:invoke:(LTest;)Ljava/lang/Object; 28: pop 29: return 可以看到一共有 4 条 inDy 指令，包括构造函数，访问成员变量，和不存在的方法调用都是 通过 invokedynamic 实现的。 再看一下引导方法表 BootstrapMethods: 0: #38 invokestatic org/codehaus/groovy/vmplugin/v7/IndyInterface.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;I)Ljava/lang/invoke/CallSite; Method arguments: #39 &amp;lt;init&amp;gt; #40 0 1: #38 invokestatic org/codehaus/groovy/vmplugin/v7/IndyInterface.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;I)Ljava/lang/invoke/CallSite; Method arguments: #46 () #40 0 2: #38 invokestatic org/codehaus/groovy/vmplugin/v7/IndyInterface.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;I)Ljava/lang/invoke/CallSite; Method arguments: #51 a #52 4 3: #38 invokestatic org/codehaus/groovy/vmplugin/v7/IndyInterface.bootstrap:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;I)Ljava/lang/invoke/CallSite; Method arguments: #58 doSomething #40 0 可以发现所有 inDy 指令的引导方法都是 IndyInterface.bootstrap 以方法调用的 inDy 指令为例，它的方法名称是 “invoke”，方法签名是 methodType(Object.class,Test.class)，BSM 方法还附带两个参数分别是实际的方法名：&quot;doSomething&quot; 和一个标志：0 BSM 方法最终调用的是 realBootstrap 方法： private static CallSite realBootstrap(Lookup caller, String name, int callID, MethodType type, boolean safe, boolean thisCall, boolean spreadCall) { MutableCallSite mc = new MutableCallSite(type); //这里是 MutableCallSite，lambda 表达式用的是 ConstantCallSite MethodHandle mh = makeFallBack(mc,caller.lookupClass(),name,callID,type,safe,thisCall,spreadCall); mc.setTarget(mh); return mc; } 主要的代码是调用 makeFallBack 来获取一个临时的 MethodHandle。因为在第一步 groovy 无法确定接收者（receiver），也是就是 invoke 方法的第一个实参（Test 实例），必须要在第二步确定 CallSite 后才会传递过来。所以方法解析要放在第二步。 protected static MethodHandle makeFallBack(MutableCallSite mc, Class&amp;lt;?&amp;gt; sender, String name, int callID, MethodType type, boolean safeNavigation, boolean thisCall, boolean spreadCall) { MethodHandle mh = MethodHandles.insertArguments(SELECT_METHOD, 0, mc, sender, name, callID, safeNavigation, thisCall, spreadCall, /*dummy receiver:*/ 1); //MethodHandle(Object.class,Object[].class) mh = mh.asCollector(Object[].class, type.parameterCount()). asType(type); return mh; } 这个 fallback 方法其实就是 selectMethod。insertArguments 在这里主要做了一个柯里化的操作，因为selectMethod 的方法签名是 methodType(Object.class, MutableCallSite.class, Class.class, String.class, int.class, Boolean.class, Boolean.class, Boolean.class, Object.class, Object[].class) 而 inDy 要求的方法签名却是 methodType(Object.class,Test.class)。 所以得经过 insertArguments 的变换，把确定的值填充进去，用最后的数组参数来接收 inDy 传递的参数。这样这个方法就能够被 inDy 调用了。第一步创建 CallSite 到这里就结束。 第二步，就是 selectMethod 方法的调用，这时候 groovy 已经知道方法的接收者 arguments[0]， public static Object selectMethod(MutableCallSite callSite, Class sender, String methodName, int callID, Boolean safeNavigation, Boolean thisCall, Boolean spreadCall, Object dummyReceiver, Object[] arguments) throws Throwable { Selector selector = Selector.getSelector(callSite, sender, methodName, callID, safeNavigation, thisCall, spreadCall, arguments); selector.setCallSiteTarget(); MethodHandle call = selector.handle.asSpreader(Object[].class, arguments.length); call = call.asType(MethodType.methodType(Object.class,Object[].class)); return call.invokeExact(arguments); } 首先创建一个方法解析器，在这里是 MethodSelector。接着调用 setCallSiteTarget()，这个方法就是用来解析实际的方法。具体的过程还是很复杂的，所以也没法说清楚，大体来说就是确定接收者的 MetaClass，决定这个方法是实际的方法，还是交给 MetaClass 的钩子方法，然后就是创建这个方法的 MethodHandle，然后把这个 MethodHandle 的签名转化为要求的签名。这时 selecor.handle 就是最终调用的方法句柄了。接下来就是最终的方法调用了，到这里 inDy 指令就执行完毕了。 还有一个方法值得留意： public void doCallSiteTargetSet() { if (!cache) { if (LOG_ENABLED) LOG.info(&quot;call site stays uncached&quot;); } else { callSite.setTarget(handle); if (LOG_ENABLED) LOG.info(&quot;call site target set, preparing outside invocation&quot;); } } 这也是为什么用 MutableCallSite 的原因，如果编译器认为这个方法是可以缓存，那么就会把这个 CallSite 绑定到实际的 MethodHandle，后续的调用就不用再重新解析了。 最后 没有相关经验，inDy 还是很不好理解的，学习了 java 8 和 groovy 对 inDy 的应用才有一点大致的认识，文中如果有什么错误，还请帮忙指出。</summary></entry><entry><title type="html">Android Architecture Component – Lifecycle 浅析</title><link href="http://dourok.info/2017/05/23/lifecycle/" rel="alternate" type="text/html" title="Android Architecture Component – Lifecycle 浅析" /><published>2017-05-23T00:00:00+00:00</published><updated>2017-11-30T15:56:47+00:00</updated><id>http://dourok.info/2017/05/23/lifecycle</id><content type="html" xml:base="http://dourok.info/2017/05/23/lifecycle/">&lt;h3 id=&quot;lifecycle&quot;&gt;Lifecycle&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/lifecycle.html&quot;&gt;Lifecycle&lt;/a&gt; 是 &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/index.html&quot;&gt;Android Architecture Components&lt;/a&gt; 的一个组件，用于将系统组件（Activity、Fragment等等）的生命周期分离到 &lt;code&gt;Lifecycle&lt;/code&gt; 类，&lt;code&gt;Lifecycle&lt;/code&gt; 允许其他类作为观察者，观察组件生命周期的变化。Lifecycle 用起来很简单，首先声明一个 &lt;code&gt;LifecycleObserver&lt;/code&gt; 对象，用 &lt;code&gt;@OnLifecycleEvent&lt;/code&gt; 注解声明生命周期事件回调的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class LifecycleObserverDemo implements LifecycleObserver {

    @OnLifecycleEvent(Lifecycle.Event.ON_ANY)
    void onAny(LifecycleOwner owner, Lifecycle.Event event) {
        System.out.println(&quot;onAny:&quot; + event.name());
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    void onCreate() {
        System.out.println(&quot;onCreate&quot;);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    void onDestroy() {
        System.out.println(&quot;onDestroy&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在 &lt;code&gt;LifecycleRegistryOwner&lt;/code&gt; 比如 &lt;code&gt;LifecycleActivity&lt;/code&gt; 加入这么一行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    getLifecycle().addObserver(new LifecycleObserverDemo());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后？然后就没了，运行起来可以看到 &lt;code&gt;LifecycleActivity&lt;/code&gt; 的生命周期发生变化时，&lt;code&gt;LifecycleObserverDemo&lt;/code&gt; 总能得到通知。而 &lt;code&gt;LifecycleActivity&lt;/code&gt; 只有寥寥几行代码，并没有覆盖任何回调方法。那么 Lifecycle 是怎么做到的，是不是有点黑魔法的感觉？&lt;/p&gt;

&lt;h3 id=&quot;注解的作用&quot;&gt;注解的作用&lt;/h3&gt;

&lt;p&gt;首先从注解入手，可以在 build 目录下发现注解处理器为我们生成了 &lt;code&gt;LifecycleObserverDemo_LifecycleAdapter&lt;/code&gt;，不过这只是一个适配器，用于将生命周期事件派发到 &lt;code&gt;LifecycleObserverDemo&lt;/code&gt; 对应的方法。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LifecycleObserverDemo_LifecycleAdapter&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GenericLifecycleObserver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LifecycleObserverDemo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mReceiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;LifecycleObserverDemo_LifecycleAdapter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LifecycleObserverDemo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mReceiver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onStateChanged&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LifecycleOwner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Event&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mReceiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onAny&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ON_CREATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;mReceiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ON_START&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;mReceiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ON_PAUSE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;mReceiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onPause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ON_DESTROY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;mReceiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onDestroy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getReceiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mReceiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;如何传达-lifecycle-事件&quot;&gt;如何传达 lifecycle 事件&lt;/h3&gt;

&lt;p&gt;注解也没有生成任何相关的代码，而 Activity 不用写任何代码，那么 Lifecycle 是如何把 Activity 生命周期事件传递给 &lt;code&gt;LifecycleObserver&lt;/code&gt;的？&lt;/p&gt;

&lt;p&gt;最终通过研读 Lifecycle 的代码，发现里面有个包可见的类 &lt;code&gt;LifecycleDispatcher&lt;/code&gt;，&lt;code&gt;LifecycleDispatcher&lt;/code&gt; 是一个单例，在 &lt;code&gt;LifecycleDispatcher#init(Context)&lt;/code&gt; 中，它通过 &lt;code&gt;registerActivityLifecycleCallbacks&lt;/code&gt; 方法，向当前的 Application 注册一个 &lt;code&gt;DispatcherActivityCallback&lt;/code&gt;，但 Lifecycle 并没使用 &lt;code&gt;ActivityLifecycleCallbacks&lt;/code&gt; 来监听并派发生命周期事件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void init(Context context){
    ...
    ((Application)context.getApplicationContext()).registerActivityLifecycleCallbacks(new LifecycleDispatcher.DispatcherActivityCallback());
    ...
}

static class DispatcherActivityCallback extends EmptyActivityLifecycleCallbacks {
    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
        ...
        if(manager.findFragmentByTag(&quot;android.arch.lifecycle.LifecycleDispatcher.report_fragment_tag&quot;) == null) {
            manager.beginTransaction().add(new ReportFragment(), &quot;android.arch.lifecycle.LifecycleDispatcher.report_fragment_tag&quot;).commit();
            manager.executePendingTransactions();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而是通过一个无 UI 的 Fragment，在 &lt;code&gt;DispatcherActivityCallback#onActivityCreated&lt;/code&gt; 可以看到它在 &lt;code&gt;Activity#onCreate&lt;/code&gt; 时，为 Activity 添加一个 &lt;code&gt;ReportFragment&lt;/code&gt;。最终由 &lt;code&gt;ReportFragment&lt;/code&gt; 来监听各个生命周期事件，然后传递给 &lt;code&gt;LifecycleRegistry&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ReportFragment extends Fragment {
    ...
    public void onPause() {
        super.onPause();
        dispatch(Event.ON_PAUSE);
    }
    ...
    private void dispatch(Event event) {
        if(this.getActivity() instanceof LifecycleRegistryOwner) {
            ((LifecycleRegistryOwner)this.getActivity()).getLifecycle().handleLifecycleEvent(event);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Activity 的生命周期事件都会派发到它的 Fragments，向 Activity 注册一个无 UI 的 Fragment 也叫 Headless Fragment 用于将各种 Activity 回调分离出来是个常用的做法&lt;/em&gt;，比如 &lt;a href=&quot;https://github.com/tbruyelle/RxPermissions&quot;&gt;RxPermissions&lt;/a&gt; 也是用这种方法来避免复写 &lt;code&gt;Activity#onRequestPermissionsResult&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;顺便一提 &lt;a href=&quot;https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.html&quot;&gt;Lifecycle 文档&lt;/a&gt;提到：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ON_CREATE, ON_START, ON_RESUME events in this class are dispatched &lt;em&gt;after&lt;/em&gt; the LifecycleOwner’s related method returns. ON_PAUSE, ON_STOP, ON_DESTROY events in this class are dispatched &lt;em&gt;before&lt;/em&gt; the LifecycleOwner’s related method is called.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;正好是 Fragment 生命周期回调的触发顺序。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Activity&lt;/code&gt; 的生命周期变化是如何传递到 &lt;code&gt;LifecycleObserver&lt;/code&gt; 有了清晰的图表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/64766-e57813cb987f6d6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;生命周期传递到 LifecycleObserver&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;lifecycleruntimetrojanprovider&quot;&gt;LifecycleRuntimeTrojanProvider&lt;/h3&gt;

&lt;p&gt;还有一个问题， &lt;code&gt;LifecycleDispatcher#init(Context)&lt;/code&gt; 并不是入口，它也需要被调用。那么他的调用者是谁？Google 这里的做法还是很巧妙的，如果这时把 apk 的 AndroidManifest.xml 提取出来，就会发现多了一个 ContentProvider 声明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;provider
        android:name=&quot;android.arch.lifecycle.LifecycleRuntimeTrojanProvider&quot;
        android:authorities=&quot;${applicationId}.lifecycle-trojan&quot;
        android:exported=&quot;false&quot;
        android:multiprocess=&quot;true&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;LifecycleRuntimeTrojanProvider&lt;/code&gt;，运行时木马是什么鬼？实际上，它不是一个 ContentProvider，而是利用 ContentProvider 的特点在应用程序初始化时，向其注入两行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LifecycleDispatcher.init(getContext());
ProcessLifecycleOwner.init(getContext());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里 ContentProvider 之于 Application 的作用就类似于 Headless Fragment 之于 Activity 一样，目的都是避免继承系统组件。关于 ContentProvider 的生命周期可以看 &lt;a href=&quot;https://stackoverflow.com/questions/24047248/contentprovider-destruction-lifecycle&quot;&gt;android - ContentProvider destruction/lifecycle - Stack Overflow&lt;/a&gt;，&lt;/p&gt;

&lt;h3 id=&quot;其他-lifecycleonwer&quot;&gt;其他 LifecycleOnwer&lt;/h3&gt;

&lt;p&gt;最后再提一下，Lifecycle 还提供了内置了另外三个 LifecycleOnwer：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/reference/android/arch/lifecycle/LifecycleFragment.html&quot;&gt;LifecycleFragment&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/reference/android/arch/lifecycle/LifecycleService.html&quot;&gt;LifecycleService&lt;/a&gt;，ServiceLifecycleDispatcher 将事件派发重新推到主线程消息队列，用于保证确保回调在 Service 生命周期回调后再调用。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/reference/android/arch/lifecycle/ProcessLifecycleOwner.html&quot;&gt;ProcessLifecycleOwner&lt;/a&gt;，用于监听整个应用的前后台切换。也是利用 ActivityLifecycleCallback 监听每个 Activity 的生命周期，如果 onStop 事件后，没有监听到任意的 onStart 事件，那么 ProcessLifecycleOwner 就会认为整个应用切换到后台，同时留下一个标志。如果监听到 onStart 事件，同时检查有标志那么就会认为应用回到前台。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;lifecycle-的应用&quot;&gt;Lifecycle 的应用？&lt;/h3&gt;

&lt;p&gt;有朋友在问 Lifecycle 有什么应用。我觉得 Lifecycle 最主要的作用就是在于解耦。以前我们使用一个生命周期敏感的模块 m，必须得在 Activity 子类里面添加类似下面的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;super.onCreate()
m.init()

m.release()
super.onDestory()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这类组件之多，用起来之频繁。以致于我们经常要创建一个 &lt;code&gt;BaseActivity&lt;/code&gt; 类来做这些脏活。不过，一旦我们建立了&lt;code&gt;BaseActivity&lt;/code&gt;，我们常常就能体会到 Java 单继承之痛。Activity不止一个啊：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;LifecycleActivity&lt;/code&gt;、&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;AppcompatActivity&lt;/code&gt;、&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;FragmentActivity&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;等等…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还有第三方库的，比如 &lt;code&gt;CordovaActivity&lt;/code&gt;… 。随着项目的扩大，你很难只用一类 Activity。而且有生命周期的组件不止一个，这些组件的子类也花样繁多，我们建立了 &lt;code&gt;BaseFragment&lt;/code&gt;、&lt;code&gt;BaseService&lt;/code&gt;…同时也建立了更多痛苦。&lt;strong&gt;为什么我们的模块要和这些复杂性绑定在一起？&lt;/strong&gt;生命周期敏感模块应该与独立起来，变成一个可以在任意有生命周期的组件安装的模块，所以 Lifecycle 就在帮我们做这种事情。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getLifecycle().addObserver(new LifecycleObserverDemo());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么具体一点这类生命周期敏感的组件有哪些呢？&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/lifecycle.html&quot;&gt;官方以 LocationManager 为例&lt;/a&gt;，主要作用避免 Activity 遁入后台后继续定位浪费电量。这里我以 volley 为例，举一个网络请求经常要面对的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;volleyClient.query(new Respose.Listener(){});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码是个老生常谈的问题了，&lt;code&gt;new Respose.Listener(){}&lt;/code&gt; 是 Activity 的一个匿名类，它有指向 Activity 的引用，而 Volley 是一个存活范围比 Activity 更大的实例，比如常常 VolleyClient 就是单例。这就导致了 Activity 销毁后不能及时释放，内存泄漏！当然，网络请求终会返回的，这个回调对象就会被销毁，从这个角度讲，问题也不是很大。另外一个就是请求返回的时候，我们会在 onSuccess 里操作 UI，如果 Activity 已经销毁了，没做检查的话那么就会崩溃。这些都不是大问题，但是很烦人。所以像 volley 请求这样的就是一个生命周期敏感的功能。&lt;/p&gt;

&lt;p&gt;网络请求和定位回调一样都可以归类为生命周期敏感的数据源，Google 为这种类型的数据源提供了 &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/livedata.html&quot;&gt;LiveData&lt;/a&gt;。这就是 LifecycleObserver 一个典型的应用，当然这只是 &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/livedata.html&quot;&gt;LiveData&lt;/a&gt; 的一部分功能。&lt;/p&gt;

&lt;p&gt;非数据源的生命周期敏感组件，比如说用户行为收集模块，它本身就是一个生命周期的监听者，在没有 &lt;code&gt;ActivityLifecycleCallback&lt;/code&gt; 的年代（API&amp;lt;14），常常需要在各个 Activity 中手动加入开始记录和停止纪录的代码。有了 &lt;code&gt;ActivityLifecycleCallback&lt;/code&gt; 之后，我们需要做的就变成在 &lt;code&gt;Application#onCreate&lt;/code&gt; 加一句代码。那么现在把用户行为收集模块变成 &lt;code&gt;LifecycleObserver&lt;/code&gt; 有什么好处？&lt;/p&gt;

&lt;p&gt;很遗憾，对于这个例子我暂时还想不出有什么特别好的地方，但是它能说明 LifecycleObserver 一个最主要的特点。比如我们有十个 Activity，只有 Activity1 和 Activity2 需要记录，那么用 LifecycleObserver 就可以避免用配置去声明哪些 Activity 需要记录。直接在需要记录的 Activity加入如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getLifecycle().addObserver(new OpRecorder());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是解耦的好处。能让一个与生命周期深度耦合的组件变成一个随处可安装的组件。&lt;/p&gt;

&lt;p&gt;最后，还是要回到这篇文章的主题，我们从 Lifecycle 的代码可以学到一个更大的模式。&lt;/p&gt;

&lt;p&gt;Activity 不只有生命周期回调，还有权限，onActivityResult 等等。那些需要与这些回调深度耦合的模块，利用 Lifecycle 用的技术 Headless Fragments 来解耦是个不错的方法。对于整个 Application 来说那就可以用更 tricky 的 Headless ContentProvider。&lt;/p&gt;</content><author><name></name></author><category term="coder" /><category term="Android" /><category term="生命周期" /><category term="Android Architecture Components" /><summary type="html">Lifecycle Lifecycle 是 Android Architecture Components 的一个组件，用于将系统组件（Activity、Fragment等等）的生命周期分离到 Lifecycle 类，Lifecycle 允许其他类作为观察者，观察组件生命周期的变化。Lifecycle 用起来很简单，首先声明一个 LifecycleObserver 对象，用 @OnLifecycleEvent 注解声明生命周期事件回调的方法： public class LifecycleObserverDemo implements LifecycleObserver { @OnLifecycleEvent(Lifecycle.Event.ON_ANY) void onAny(LifecycleOwner owner, Lifecycle.Event event) { System.out.println(&quot;onAny:&quot; + event.name()); } @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) void onCreate() { System.out.println(&quot;onCreate&quot;); } @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) void onDestroy() { System.out.println(&quot;onDestroy&quot;); } } 然后在 LifecycleRegistryOwner 比如 LifecycleActivity 加入这么一行代码： getLifecycle().addObserver(new LifecycleObserverDemo()); 然后？然后就没了，运行起来可以看到 LifecycleActivity 的生命周期发生变化时，LifecycleObserverDemo 总能得到通知。而 LifecycleActivity 只有寥寥几行代码，并没有覆盖任何回调方法。那么 Lifecycle 是怎么做到的，是不是有点黑魔法的感觉？ 注解的作用 首先从注解入手，可以在 build 目录下发现注解处理器为我们生成了 LifecycleObserverDemo_LifecycleAdapter，不过这只是一个适配器，用于将生命周期事件派发到 LifecycleObserverDemo 对应的方法。 public class LifecycleObserverDemo_LifecycleAdapter implements GenericLifecycleObserver { final LifecycleObserverDemo mReceiver; LifecycleObserverDemo_LifecycleAdapter(LifecycleObserverDemo receiver) { this.mReceiver = receiver; } @Override public void onStateChanged(LifecycleOwner owner, Lifecycle.Event event) { mReceiver.onAny(owner,event); if (event == Lifecycle.Event.ON_CREATE) { mReceiver.onCreate(); } if (event == Lifecycle.Event.ON_START) { mReceiver.onStart(); } if (event == Lifecycle.Event.ON_PAUSE) { mReceiver.onPause(); } if (event == Lifecycle.Event.ON_DESTROY) { mReceiver.onDestroy(); } } public Object getReceiver() { return mReceiver; } } 如何传达 lifecycle 事件 注解也没有生成任何相关的代码，而 Activity 不用写任何代码，那么 Lifecycle 是如何把 Activity 生命周期事件传递给 LifecycleObserver的？ 最终通过研读 Lifecycle 的代码，发现里面有个包可见的类 LifecycleDispatcher，LifecycleDispatcher 是一个单例，在 LifecycleDispatcher#init(Context) 中，它通过 registerActivityLifecycleCallbacks 方法，向当前的 Application 注册一个 DispatcherActivityCallback，但 Lifecycle 并没使用 ActivityLifecycleCallbacks 来监听并派发生命周期事件。 static void init(Context context){ ... ((Application)context.getApplicationContext()).registerActivityLifecycleCallbacks(new LifecycleDispatcher.DispatcherActivityCallback()); ... } static class DispatcherActivityCallback extends EmptyActivityLifecycleCallbacks { public void onActivityCreated(Activity activity, Bundle savedInstanceState) { ... if(manager.findFragmentByTag(&quot;android.arch.lifecycle.LifecycleDispatcher.report_fragment_tag&quot;) == null) { manager.beginTransaction().add(new ReportFragment(), &quot;android.arch.lifecycle.LifecycleDispatcher.report_fragment_tag&quot;).commit(); manager.executePendingTransactions(); } } } 而是通过一个无 UI 的 Fragment，在 DispatcherActivityCallback#onActivityCreated 可以看到它在 Activity#onCreate 时，为 Activity 添加一个 ReportFragment。最终由 ReportFragment 来监听各个生命周期事件，然后传递给 LifecycleRegistry。 public class ReportFragment extends Fragment { ... public void onPause() { super.onPause(); dispatch(Event.ON_PAUSE); } ... private void dispatch(Event event) { if(this.getActivity() instanceof LifecycleRegistryOwner) { ((LifecycleRegistryOwner)this.getActivity()).getLifecycle().handleLifecycleEvent(event); } } } Activity 的生命周期事件都会派发到它的 Fragments，向 Activity 注册一个无 UI 的 Fragment 也叫 Headless Fragment 用于将各种 Activity 回调分离出来是个常用的做法，比如 RxPermissions 也是用这种方法来避免复写 Activity#onRequestPermissionsResult。 顺便一提 Lifecycle 文档提到： ON_CREATE, ON_START, ON_RESUME events in this class are dispatched after the LifecycleOwner’s related method returns. ON_PAUSE, ON_STOP, ON_DESTROY events in this class are dispatched before the LifecycleOwner’s related method is called. 正好是 Fragment 生命周期回调的触发顺序。 Activity 的生命周期变化是如何传递到 LifecycleObserver 有了清晰的图表： LifecycleRuntimeTrojanProvider 还有一个问题， LifecycleDispatcher#init(Context) 并不是入口，它也需要被调用。那么他的调用者是谁？Google 这里的做法还是很巧妙的，如果这时把 apk 的 AndroidManifest.xml 提取出来，就会发现多了一个 ContentProvider 声明： &amp;lt;provider android:name=&quot;android.arch.lifecycle.LifecycleRuntimeTrojanProvider&quot; android:authorities=&quot;${applicationId}.lifecycle-trojan&quot; android:exported=&quot;false&quot; android:multiprocess=&quot;true&quot; /&amp;gt; LifecycleRuntimeTrojanProvider，运行时木马是什么鬼？实际上，它不是一个 ContentProvider，而是利用 ContentProvider 的特点在应用程序初始化时，向其注入两行代码： LifecycleDispatcher.init(getContext()); ProcessLifecycleOwner.init(getContext()); 这里 ContentProvider 之于 Application 的作用就类似于 Headless Fragment 之于 Activity 一样，目的都是避免继承系统组件。关于 ContentProvider 的生命周期可以看 android - ContentProvider destruction/lifecycle - Stack Overflow， 其他 LifecycleOnwer 最后再提一下，Lifecycle 还提供了内置了另外三个 LifecycleOnwer： LifecycleFragment LifecycleService，ServiceLifecycleDispatcher 将事件派发重新推到主线程消息队列，用于保证确保回调在 Service 生命周期回调后再调用。 ProcessLifecycleOwner，用于监听整个应用的前后台切换。也是利用 ActivityLifecycleCallback 监听每个 Activity 的生命周期，如果 onStop 事件后，没有监听到任意的 onStart 事件，那么 ProcessLifecycleOwner 就会认为整个应用切换到后台，同时留下一个标志。如果监听到 onStart 事件，同时检查有标志那么就会认为应用回到前台。 Lifecycle 的应用？ 有朋友在问 Lifecycle 有什么应用。我觉得 Lifecycle 最主要的作用就是在于解耦。以前我们使用一个生命周期敏感的模块 m，必须得在 Activity 子类里面添加类似下面的代码 super.onCreate() m.init() m.release() super.onDestory() 这类组件之多，用起来之频繁。以致于我们经常要创建一个 BaseActivity 类来做这些脏活。不过，一旦我们建立了BaseActivity，我们常常就能体会到 Java 单继承之痛。Activity不止一个啊： LifecycleActivity、 AppcompatActivity、 FragmentActivity 等等… 还有第三方库的，比如 CordovaActivity… 。随着项目的扩大，你很难只用一类 Activity。而且有生命周期的组件不止一个，这些组件的子类也花样繁多，我们建立了 BaseFragment、BaseService…同时也建立了更多痛苦。为什么我们的模块要和这些复杂性绑定在一起？生命周期敏感模块应该与独立起来，变成一个可以在任意有生命周期的组件安装的模块，所以 Lifecycle 就在帮我们做这种事情。 getLifecycle().addObserver(new LifecycleObserverDemo()); 那么具体一点这类生命周期敏感的组件有哪些呢？官方以 LocationManager 为例，主要作用避免 Activity 遁入后台后继续定位浪费电量。这里我以 volley 为例，举一个网络请求经常要面对的问题： volleyClient.query(new Respose.Listener(){}); 上面的代码是个老生常谈的问题了，new Respose.Listener(){} 是 Activity 的一个匿名类，它有指向 Activity 的引用，而 Volley 是一个存活范围比 Activity 更大的实例，比如常常 VolleyClient 就是单例。这就导致了 Activity 销毁后不能及时释放，内存泄漏！当然，网络请求终会返回的，这个回调对象就会被销毁，从这个角度讲，问题也不是很大。另外一个就是请求返回的时候，我们会在 onSuccess 里操作 UI，如果 Activity 已经销毁了，没做检查的话那么就会崩溃。这些都不是大问题，但是很烦人。所以像 volley 请求这样的就是一个生命周期敏感的功能。 网络请求和定位回调一样都可以归类为生命周期敏感的数据源，Google 为这种类型的数据源提供了 LiveData。这就是 LifecycleObserver 一个典型的应用，当然这只是 LiveData 的一部分功能。 非数据源的生命周期敏感组件，比如说用户行为收集模块，它本身就是一个生命周期的监听者，在没有 ActivityLifecycleCallback 的年代（API&amp;lt;14），常常需要在各个 Activity 中手动加入开始记录和停止纪录的代码。有了 ActivityLifecycleCallback 之后，我们需要做的就变成在 Application#onCreate 加一句代码。那么现在把用户行为收集模块变成 LifecycleObserver 有什么好处？ 很遗憾，对于这个例子我暂时还想不出有什么特别好的地方，但是它能说明 LifecycleObserver 一个最主要的特点。比如我们有十个 Activity，只有 Activity1 和 Activity2 需要记录，那么用 LifecycleObserver 就可以避免用配置去声明哪些 Activity 需要记录。直接在需要记录的 Activity加入如下代码 getLifecycle().addObserver(new OpRecorder()); 这就是解耦的好处。能让一个与生命周期深度耦合的组件变成一个随处可安装的组件。 最后，还是要回到这篇文章的主题，我们从 Lifecycle 的代码可以学到一个更大的模式。 Activity 不只有生命周期回调，还有权限，onActivityResult 等等。那些需要与这些回调深度耦合的模块，利用 Lifecycle 用的技术 Headless Fragments 来解耦是个不错的方法。对于整个 Application 来说那就可以用更 tricky 的 Headless ContentProvider。</summary></entry><entry><title type="html">解决 ViewPager 嵌套导致的 Fragment 菜单错乱</title><link href="http://dourok.info/2016/12/24/hierarchy-fragment-pager-adapter/" rel="alternate" type="text/html" title="解决 ViewPager 嵌套导致的 Fragment 菜单错乱" /><published>2016-12-24T00:00:00+00:00</published><updated>2017-11-30T15:56:47+00:00</updated><id>http://dourok.info/2016/12/24/hierarchy-fragment-pager-adapter</id><content type="html" xml:base="http://dourok.info/2016/12/24/hierarchy-fragment-pager-adapter/">&lt;p&gt;以下图嵌套的 ViewPager 为例，它是一个两层嵌套的 ViewPager，也就是说 ViewPager 里面是 Fragment ，每个 Fragment 里面又是一个 ViewPager。在下面的例子中，每个 Fragment 都有一个相同名字的菜单项，可以看到不在当前页显示的 Fragment 它的菜单项也显示出来了。用户滑动到 B ，ViewPager 能正确处理第一层的菜单，显示 B 的时候同时预加载 A、C 两个 Fragment，而菜单里只显示 B 的菜单项。到第二层就有问题了， BA 是第二层当前的 Fragment，它的菜单项也能显示出来，这没问题。但却多出来 AA 和 CA，这是因为 ViewPager 预加载了 A，A 里面的 ViewPager 把 AA 当成是当前 Fragment，把它的菜单项也显示出来了。CA 也是同样道理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;b_aa_ba_ca.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;决定是否显示菜单的代码是由 &lt;code&gt;PagerAdapter#setPrimaryItem&lt;/code&gt; 实现的，属于主项（primary item）的 fragment 才会显示菜单项。以 FragmentPagerState 为例，具体代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fragment fragment = (Fragment)object;
if (fragment != mCurrentPrimaryItem) {
    if (mCurrentPrimaryItem != null) {
        mCurrentPrimaryItem.setMenuVisibility(false);
        mCurrentPrimaryItem.setUserVisibleHint(false);
    }
    if (fragment != null) {
        fragment.setMenuVisibility(true);
        fragment.setUserVisibleHint(true);
    }
    mCurrentPrimaryItem = fragment;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AA、CA 的显示就很好理解了，因为它们各自是 A 和 C 的主项（primary item），所以都调用了 &lt;code&gt;setMenuVisibility(true)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;要修复这个问题，一开始想到的是覆盖父 fragment 的 &lt;code&gt;setMenuVisibility&lt;/code&gt; 方法，把值传递到当前子 fragment&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override public void setMenuVisibility(boolean menuVisible) {
    if (isAdded() &amp;amp;&amp;amp; getChildFragmentManager().getFragments() != null) {
      Fragment f = getChildFragmentManager().findFragmentByTag(
          &quot;android:switcher:&quot; + mPager.getId() + &quot;:&quot; + mPager.getCurrentItem());// 不支持 FragmentStatePagerAdapter
      if (f != null) {
        f.setMenuVisibility(menuVisible);
      }
    }
    super.setMenuVisibility(menuVisible);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样从 A 滑到 B 时，AA 能隐藏了。但仍然不能解决问题，从 A 滑到 B 时离屏加载 C，并设置 C 的 MenuVisibility 为 false。FragmentPagerAdapter 几次 setMenuVisibility 都在 finishUpdate 之前，所以此时 C 还未添加到 Activity，CA 更不存在。等到 CA 加载时，已经不会再触发 C 的 MenuVisibility 了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;b_ba_ca.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;考虑自定义 FragmentPagerAdapter，主项（primary item）的 fragment 的 menuVisibility 同步父 Fragment 的状态，&lt;code&gt;mParent&lt;/code&gt; 是适配器构造函数传入的 ViewPager 宿主 Fragment。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override public void setPrimaryItem(ViewGroup container, int position, Object object) {
  super.setPrimaryItem(container, position, object);
  if (mParent != null) ((Fragment) object).setMenuVisibility(mParent.isMenuVisible());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的问题是，从 A 滑到 B 时，只是根 ViewPager 的当前主项（primary item）发生变化，A 适配器和 B 适配器的主项不会发生变化，所以 setPrimaryItem 不会被触发，AA 的菜单仍然可见，而 BA 的菜单则仍然不可见。&lt;/p&gt;

&lt;p&gt;幸运的是把修改两个地方合并起来，这样就覆盖了各种可能了。但未免过于繁琐，把问题重新整理一遍，建立模型，才是优雅的解决方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;给适配器（Adapter）引入是否可视（visible)属性，不再是主项（primary item）的 Fragment 就显示菜单，而是只有当前适配器是可视的情况下才可以显示菜单。&lt;/li&gt;
  &lt;li&gt;是否可视的递归定义：父适配器（管理&lt;strong&gt;宿主 Fragment&lt;/strong&gt; 的 Adapter）是可视的 ，且&lt;strong&gt;宿主 Fragment&lt;/strong&gt; 是主项，适配器才是可视的。&lt;/li&gt;
  &lt;li&gt;父适配器的可视状态和&lt;strong&gt;宿主 Fragment&lt;/strong&gt; 主项状态发生改变，要传递到其子适配器。&lt;/li&gt;
  &lt;li&gt;子适配器初始化要正确初始化他的可视状态。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样就能设计一个新的 PagerAdapter，把棘手的问题都放在 PagerAdapter 来做。&lt;/p&gt;

&lt;p&gt;要实现第三点，适配器需要获得指向其子适配器的引用，适配器是 Fragments 的管理者，这些 Fragments 又是子适配器的宿主，只要让 Fragment 实现接口来获取其内部的适配器便行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface AdapterHolder {
    HierarchyFragmentPagerAdapter getAdapter();
  }

/**
 * 通知子 Adapter（宿主是 holder） ，父 Adapter(当前的 Adapter) visible 发生了变化。
 * 或者通知子 Adapter，父 Adapter 希望它的 visible 发生变化
 */
private void notifyChildVisibleChanged(boolean visible, Fragment holder) {
  if (holder instanceof AdapterHolder) {
    HierarchyFragmentPagerAdapter adapter = ((AdapterHolder) holder).getAdapter();
    if (adapter != null) {
      adapter.setVisible(visible);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有继承 AdapterHolder 都会被适配器当成没有子 Adapter。&lt;/p&gt;

&lt;p&gt;相比第三点，第四点反而更麻烦。在 finishUpdate 之前，Fragment 是不知道它在树中的位置的。这时如果尝试用 &lt;code&gt;getParentFragment()&lt;/code&gt; 是返回空，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Fragment parent = fragment.getParentFragment();
    if (parent == null || !(parent instanceof AdapterHolder)) {
      // 拿不到 parent 有两种情况
      // Adapter 在根 Pager 里
      // 也有可能是第一次初始化，当前 Fragment 还未和其父 Fragment 建立链接
      setVisible(isVisible());
    } else {
      // 否则，只有父 Adapter 是 visible primary，当前 primary item 才可能是 visible primary.
      setVisible(((AdapterHolder) parent).getAdapter().isVisible());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了能够正确初始化，需要在构造函数做个 hack。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public HierarchyFragmentPagerAdapter(PagerAdapter adapter, AdapterHolder holder) {
   mAdapter = adapter;
   mVisible = true;
   if (holder != null) {
     if (holder instanceof Fragment) {
       // 一个 hack，初始化 的 visible 状态
       // holder 不是 Fragment 表示 Adapter 为根 Adapter
       // menu visible 为 true，便断言宿主 Fragment 是 primary item.
       mVisible = ((Fragment) holder).isMenuVisible();
     }
   }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;剩下的便没什么，鉴于 PagerAdapter 有两个, FragmentPagerAdapter 和 FragmentStatePagerAdapter。所以适配器的设计便用代理模式比较合适，实现起来比想象中的简洁，用起来也简单，只需将实际的 PagerAdapter 外面包一层 &lt;code&gt;HierarchyFragmentPagerAdapter&lt;/code&gt; 就行，具体的代码见：&lt;a href=&quot;https://github.com/douo/android-demo/blob/master/app/src/main/java/info/dourok/android/demo/pager/HierarchyFragmentPagerAdapter.java&quot;&gt;HierarchyFragmentPagerAdapter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;b_ba_baa_baaa.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="coder" /><category term="Android" /><category term="ViewPager" /><summary type="html">以下图嵌套的 ViewPager 为例，它是一个两层嵌套的 ViewPager，也就是说 ViewPager 里面是 Fragment ，每个 Fragment 里面又是一个 ViewPager。在下面的例子中，每个 Fragment 都有一个相同名字的菜单项，可以看到不在当前页显示的 Fragment 它的菜单项也显示出来了。用户滑动到 B ，ViewPager 能正确处理第一层的菜单，显示 B 的时候同时预加载 A、C 两个 Fragment，而菜单里只显示 B 的菜单项。到第二层就有问题了， BA 是第二层当前的 Fragment，它的菜单项也能显示出来，这没问题。但却多出来 AA 和 CA，这是因为 ViewPager 预加载了 A，A 里面的 ViewPager 把 AA 当成是当前 Fragment，把它的菜单项也显示出来了。CA 也是同样道理。 决定是否显示菜单的代码是由 PagerAdapter#setPrimaryItem 实现的，属于主项（primary item）的 fragment 才会显示菜单项。以 FragmentPagerState 为例，具体代码如下: Fragment fragment = (Fragment)object; if (fragment != mCurrentPrimaryItem) { if (mCurrentPrimaryItem != null) { mCurrentPrimaryItem.setMenuVisibility(false); mCurrentPrimaryItem.setUserVisibleHint(false); } if (fragment != null) { fragment.setMenuVisibility(true); fragment.setUserVisibleHint(true); } mCurrentPrimaryItem = fragment; } AA、CA 的显示就很好理解了，因为它们各自是 A 和 C 的主项（primary item），所以都调用了 setMenuVisibility(true)。 要修复这个问题，一开始想到的是覆盖父 fragment 的 setMenuVisibility 方法，把值传递到当前子 fragment @Override public void setMenuVisibility(boolean menuVisible) { if (isAdded() &amp;amp;&amp;amp; getChildFragmentManager().getFragments() != null) { Fragment f = getChildFragmentManager().findFragmentByTag( &quot;android:switcher:&quot; + mPager.getId() + &quot;:&quot; + mPager.getCurrentItem());// 不支持 FragmentStatePagerAdapter if (f != null) { f.setMenuVisibility(menuVisible); } } super.setMenuVisibility(menuVisible); } 这样从 A 滑到 B 时，AA 能隐藏了。但仍然不能解决问题，从 A 滑到 B 时离屏加载 C，并设置 C 的 MenuVisibility 为 false。FragmentPagerAdapter 几次 setMenuVisibility 都在 finishUpdate 之前，所以此时 C 还未添加到 Activity，CA 更不存在。等到 CA 加载时，已经不会再触发 C 的 MenuVisibility 了。 考虑自定义 FragmentPagerAdapter，主项（primary item）的 fragment 的 menuVisibility 同步父 Fragment 的状态，mParent 是适配器构造函数传入的 ViewPager 宿主 Fragment。 @Override public void setPrimaryItem(ViewGroup container, int position, Object object) { super.setPrimaryItem(container, position, object); if (mParent != null) ((Fragment) object).setMenuVisibility(mParent.isMenuVisible()); } 这样的问题是，从 A 滑到 B 时，只是根 ViewPager 的当前主项（primary item）发生变化，A 适配器和 B 适配器的主项不会发生变化，所以 setPrimaryItem 不会被触发，AA 的菜单仍然可见，而 BA 的菜单则仍然不可见。 幸运的是把修改两个地方合并起来，这样就覆盖了各种可能了。但未免过于繁琐，把问题重新整理一遍，建立模型，才是优雅的解决方法： 给适配器（Adapter）引入是否可视（visible)属性，不再是主项（primary item）的 Fragment 就显示菜单，而是只有当前适配器是可视的情况下才可以显示菜单。 是否可视的递归定义：父适配器（管理宿主 Fragment 的 Adapter）是可视的 ，且宿主 Fragment 是主项，适配器才是可视的。 父适配器的可视状态和宿主 Fragment 主项状态发生改变，要传递到其子适配器。 子适配器初始化要正确初始化他的可视状态。 这样就能设计一个新的 PagerAdapter，把棘手的问题都放在 PagerAdapter 来做。 要实现第三点，适配器需要获得指向其子适配器的引用，适配器是 Fragments 的管理者，这些 Fragments 又是子适配器的宿主，只要让 Fragment 实现接口来获取其内部的适配器便行。 public interface AdapterHolder { HierarchyFragmentPagerAdapter getAdapter(); } /** * 通知子 Adapter（宿主是 holder） ，父 Adapter(当前的 Adapter) visible 发生了变化。 * 或者通知子 Adapter，父 Adapter 希望它的 visible 发生变化 */ private void notifyChildVisibleChanged(boolean visible, Fragment holder) { if (holder instanceof AdapterHolder) { HierarchyFragmentPagerAdapter adapter = ((AdapterHolder) holder).getAdapter(); if (adapter != null) { adapter.setVisible(visible); } } } 没有继承 AdapterHolder 都会被适配器当成没有子 Adapter。 相比第三点，第四点反而更麻烦。在 finishUpdate 之前，Fragment 是不知道它在树中的位置的。这时如果尝试用 getParentFragment() 是返回空， Fragment parent = fragment.getParentFragment(); if (parent == null || !(parent instanceof AdapterHolder)) { // 拿不到 parent 有两种情况 // Adapter 在根 Pager 里 // 也有可能是第一次初始化，当前 Fragment 还未和其父 Fragment 建立链接 setVisible(isVisible()); } else { // 否则，只有父 Adapter 是 visible primary，当前 primary item 才可能是 visible primary. setVisible(((AdapterHolder) parent).getAdapter().isVisible()); } 为了能够正确初始化，需要在构造函数做个 hack。 public HierarchyFragmentPagerAdapter(PagerAdapter adapter, AdapterHolder holder) { mAdapter = adapter; mVisible = true; if (holder != null) { if (holder instanceof Fragment) { // 一个 hack，初始化 的 visible 状态 // holder 不是 Fragment 表示 Adapter 为根 Adapter // menu visible 为 true，便断言宿主 Fragment 是 primary item. mVisible = ((Fragment) holder).isMenuVisible(); } } } 剩下的便没什么，鉴于 PagerAdapter 有两个, FragmentPagerAdapter 和 FragmentStatePagerAdapter。所以适配器的设计便用代理模式比较合适，实现起来比想象中的简洁，用起来也简单，只需将实际的 PagerAdapter 外面包一层 HierarchyFragmentPagerAdapter 就行，具体的代码见：HierarchyFragmentPagerAdapter</summary></entry><entry><title type="html">分享我的 Android Studio Emacs 风格快捷键</title><link href="http://dourok.info/2016/08/20/share-my-android-studio-emacs-keymaps/" rel="alternate" type="text/html" title="分享我的 Android Studio Emacs 风格快捷键" /><published>2016-08-20T00:00:00+00:00</published><updated>2017-11-30T15:56:47+00:00</updated><id>http://dourok.info/2016/08/20/share-my-android-studio-emacs-keymaps</id><content type="html" xml:base="http://dourok.info/2016/08/20/share-my-android-studio-emacs-keymaps/">&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/3/3a/Qwerty.svg&quot; alt=&quot;QWERTY 键盘区域，来自 wikimedia&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Emacs 风格的快捷键通过&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Prefix-Keys.html&quot;&gt;前缀键&lt;/a&gt;来扩展更多打字区的快捷键，尽量把快捷键控制在打字键区，显著减少编码过程手腕的移动，是个经得起考验的快捷键方案（非 emacs 用户可能深痛恶觉）。&lt;/p&gt;

&lt;p&gt;这套快捷键在 Emacs keymaps 的基础上进行自定义，首先减少对功能键区的使用，一来容易与系统快捷键冲突，二来手指移动的幅度过大难定位不容形成肌肉记忆，所以只保留编译运行相关的快捷键。至于编辑键区则更次，手腕必须得移动，眼睛也得跟着辅助定位，只保留少部分不常用的默认快捷键。数字键区最糟，手腕移动幅度最大，再说我的 87 键盘都没有小键盘-_-，直接弃用。至于鼠标，那更是万恶之源，整个手臂都得移动，还要眼睛配合才能用鼠标完成一次操作，写代码的过程大多是用鼠标辅助点击几次，然后又回到打字区继续敲，这样来回一次切换成本太高。何况程序员经常用鼠标点点点？多没 B 格啊。虽说如此，不过想要完全不用鼠标还是不太容易，只能说一个命令通过鼠标打开层层菜单来执行超过一次，第二次就应该用 Find Action 来执行，如果一天超过三次那就应该给它设个快捷键并记住。&lt;/p&gt;

&lt;p&gt;Android Studio 相比 Eclipse 内置的 Emacs keymaps 强大了许多，不过 Eclipse 有 Emacs+， Android Studio 却没有这方面的插件。所有 Android Studio 相比 Emacs 多了一些不足，比如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Android Studio 只支持一个前缀键（prefix key），所以 spacemacs 那样的助记法快捷键 Android Studio 难以实现&lt;/li&gt;
  &lt;li&gt;Android Studio 中 Esc 不能作为修饰键使用&lt;/li&gt;
  &lt;li&gt;IntelliJ 可以为 &lt;code&gt;Escape&lt;/code&gt; 命令配置快捷键，但不少 UI 还是硬编码为键盘的 &lt;code&gt;Esc&lt;/code&gt; 键。所以为了退出浮窗，经常要 &lt;code&gt;C-g&lt;/code&gt;、&lt;code&gt;Esc&lt;/code&gt; 交替使用&lt;/li&gt;
  &lt;li&gt;不过窗口的操作逻辑不一致，有些 UI 可以用移动光标快捷键，有些只能用方向键&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一些约定先说明，特别是非 Emacs 党：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C = Control/Ctrl，&lt;a href=&quot;https://www.emacswiki.org/emacs/MovingTheCtrlKey&quot;&gt;如果小指还想要请将 CapsLock 改成 Ctrl&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;M = Meta = Alt != Options&lt;/li&gt;
  &lt;li&gt;S = Shift&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;C-F&lt;/code&gt; 等同于 &lt;code&gt;C-S-f&lt;/code&gt; ，无换档字符仍使用 &lt;code&gt;C-S-key&lt;/code&gt; 表示&lt;/li&gt;
  &lt;li&gt;方向用图标表示：&lt;code&gt;←&lt;/code&gt;、&lt;code&gt;→&lt;/code&gt;、&lt;code&gt;↑&lt;/code&gt;、&lt;code&gt;↓&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;,&lt;/code&gt; 用于分隔前缀键，表示先按 &lt;code&gt;,&lt;/code&gt; 前的键，&lt;em&gt;松开&lt;/em&gt;，再按下一个键&lt;/li&gt;
  &lt;li&gt;关于 Mac 的 Options 键，参考：&lt;a href=&quot;https://stackoverflow.com/questions/20770033/how-to-disable-option-key-to-type-greek-letter-in-mac-os&quot;&gt;osx - How to disable option key to type greek letter in Mac OS? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最终使用的前缀键有下面三个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;C-x&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Esc&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;M-g&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先，最基本又最重要的键肯定就是 Find Action，简直就是 Emacs 中的 Run Command，必须绑定为 &lt;code&gt;M-x&lt;/code&gt;。别的快捷键记不住不要紧，只要记住这个还是能做到无鼠标操作，特别是还附带快捷键提示，如果有的话。不过还是得对命令的关键字有点概念，表格中的关键字项就是表示通过该关键字在 Find Action 或者 Keymaps 设置搜索到相应功能；自定义有 &lt;code&gt;*&lt;/code&gt; 表示快捷键是我自定义的，非 Emacs Keymaps 的默认配置。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;执行命令&lt;/td&gt;
      &lt;td&gt;find Action&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-g&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;取消&lt;/td&gt;
      &lt;td&gt;escape&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-M-s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;打开设置&lt;/td&gt;
      &lt;td&gt;settings&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;光标移动move-cursor&quot;&gt;光标移动（Move cursor）&lt;/h3&gt;

&lt;p&gt;光标移动类的快捷键，这里指的是在单一文本的内的光标移动，又包括语法无关的移动和语法相关的移动，语法无关的移动指的就是光标的上下左右移动等等，这一块与 Emacs 基本一致。另外 &lt;code&gt;C-l&lt;/code&gt;虽然不是移动光标，但也是放在这里。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;向前移动一个字符&lt;/td&gt;
      &lt;td&gt;right&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;向后移动一个字符&lt;/td&gt;
      &lt;td&gt;left&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-n&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;向上移动一行&lt;/td&gt;
      &lt;td&gt;up&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-p&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;向下移动一行&lt;/td&gt;
      &lt;td&gt;down&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;向前移动一个单词&lt;/td&gt;
      &lt;td&gt;next word&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;向后移动一个单词&lt;/td&gt;
      &lt;td&gt;previous word&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动到行头&lt;/td&gt;
      &lt;td&gt;line start&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-e&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动到行尾&lt;/td&gt;
      &lt;td&gt;line end&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-v&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;下一页&lt;/td&gt;
      &lt;td&gt;page down&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-v&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上一页&lt;/td&gt;
      &lt;td&gt;page up&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-&amp;lt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动到文本头&lt;/td&gt;
      &lt;td&gt;text start&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动到文本尾&lt;/td&gt;
      &lt;td&gt;text end&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-l&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;将光标位置滚动到屏幕中央&lt;/td&gt;
      &lt;td&gt;scroll to center&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-Pgup&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动到当前页的起始处&lt;/td&gt;
      &lt;td&gt;Page Top&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-PgDn&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动到当前页的结束处&lt;/td&gt;
      &lt;td&gt;page end&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;语法相关的移动：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-[&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动到当前 Block 起始大括号处&lt;/td&gt;
      &lt;td&gt;Code block start&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-]&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动到当前 BLock 结束大括号处&lt;/td&gt;
      &lt;td&gt;Code Block End&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-M-a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动到前一个方法&lt;/td&gt;
      &lt;td&gt;previous method&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-M-e&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动到后一个方法&lt;/td&gt;
      &lt;td&gt;next method&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Android Studio 将 &lt;code&gt;M-g&lt;/code&gt; 作为跳转到行数，我改其作为前置键，同时作为跳转高亮错误的前置键。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g g&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;作为跳转到行数&lt;/td&gt;
      &lt;td&gt;line&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g n&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;下一个高亮问题&lt;/td&gt;
      &lt;td&gt;next highlighted error&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g p&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上一个高亮问题&lt;/td&gt;
      &lt;td&gt;next highlighted error&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;与光标相关的还有文本选择，我保留 &lt;code&gt;C-space&lt;/code&gt; 来加入选择模式，但这个快捷键也常被操作系统用来切换输入法，
在 Linux 下我把输入切换配置为 Win-space，其他系统我也建议想办法把 C-space 留给 Android Studio。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-space&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;切换选择模式&lt;/td&gt;
      &lt;td&gt;sticky selection&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, h&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;全选&lt;/td&gt;
      &lt;td&gt;select all&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;特别是 Android Studio 不像 emacs 可以用 &lt;code&gt;C-F&lt;/code&gt; 等进行选择。只能用传统的 &lt;code&gt;S-→&lt;/code&gt;。所以保留 C-space 还是有必要的，下面是例外：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-{&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;选择到当前 Block 起始大括号处&lt;/td&gt;
      &lt;td&gt;Code block start&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;选择到当前 Block 结束大括号处&lt;/td&gt;
      &lt;td&gt;Code block end&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-S-PgUp&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;选择到当前页的起始处&lt;/td&gt;
      &lt;td&gt;page start&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-S-PgDn&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;选择到当前页的结束处&lt;/td&gt;
      &lt;td&gt;page end&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-S-Home&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;选择到当前文本的起始处&lt;/td&gt;
      &lt;td&gt;text start&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-S-End&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;选择到当前文本的结束处&lt;/td&gt;
      &lt;td&gt;text end&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;导航navigate&quot;&gt;导航（Navigate）&lt;/h3&gt;

&lt;p&gt;导航，在不同文件中切换。常用的导航我用一段式快捷键。一定要善用前三个，对编码效率绝对是很大的提高，起码不会让切换文件的速度脱慢你的思路。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-M-G&lt;/code&gt; 是 &lt;code&gt;C-M-g&lt;/code&gt; 的高级版，直接从实例名跳转到其类中。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-M-f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;上一个位置&lt;/td&gt;
      &lt;td&gt;forward&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-M-b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;下一个位置&lt;/td&gt;
      &lt;td&gt;back&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-M-g&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;跳转到定义处&lt;/td&gt;
      &lt;td&gt;declaration&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-M-G&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;跳转到类型&lt;/td&gt;
      &lt;td&gt;type declaration&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-M-u&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;跳转到父类方法&lt;/td&gt;
      &lt;td&gt;super method&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-←/→&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;左右切换标签&lt;/td&gt;
      &lt;td&gt;select tab&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果对简洁有要求或者屏幕太小（比如我），可以将 Android Studio 的标签关掉，具体参考：&lt;a href=&quot;https://www.jetbrains.com/help/idea/2016.2/configuring-behavior-of-the-editor-tabs.html&quot;&gt;Configuring Behavior of the Editor Tabs&lt;/a&gt;，那么这时 &lt;code&gt;M-←/→&lt;/code&gt; 就不会起作用了。&lt;/p&gt;

&lt;p&gt;另外 &lt;code&gt;M-num&lt;/code&gt; 都被 Android Studio 绑定到切换功能窗体，很实用但不一一罗列了，比较常用的是 &lt;code&gt;M-6&lt;/code&gt; 打开 Android Monitor、&lt;code&gt;M-7&lt;/code&gt; 打开 Structure，至于 Project 有更好的快捷键打开。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-num&lt;/code&gt; 用于跳转书签。&lt;code&gt;C-M-num&lt;/code&gt; 则用于设置书签，书签是全局的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Select in…&lt;/strong&gt; 可谓的鼠标杀手中的 MVP，多少鼠标操作就是为了在其他窗体中操作当前文件。大部分情况下它都是比 &lt;code&gt;M-num&lt;/code&gt; 更好的选择。默认的 &lt;code&gt;Alt+F1&lt;/code&gt; 与系统冲突，我修改为 &lt;code&gt;Esc，S-i&lt;/code&gt;，好记，不过需要前缀键确实难为了这个命令。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;Esc,S-i&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;在其它窗体中选择，比如在项目窗体定位当前文件&lt;/td&gt;
      &lt;td&gt;select in..&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;S-Esc&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;隐藏工具窗口，配合上个命令使用更佳。&lt;/td&gt;
      &lt;td&gt;Hide Active ToolWindow&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-S-Esc&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;隐藏所有工具窗口&lt;/td&gt;
      &lt;td&gt;Hide All ToolWindow&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;编辑edit&quot;&gt;编辑（Edit）&lt;/h3&gt;

&lt;p&gt;看快捷键说明， Android Studio 有 kill ring 的概念，比如 &lt;code&gt;M-w&lt;/code&gt;、&lt;code&gt;C-w&lt;/code&gt;、&lt;code&gt;M-d&lt;/code&gt;、&lt;code&gt;M-backspace&lt;/code&gt; 都是操作 kill ring，但是居然没有 yank pop，所以 &lt;code&gt;M-y&lt;/code&gt; 只能绑定为不太实用 &lt;strong&gt;paste from history…&lt;/strong&gt;，话说你把 kill ring 藏到哪了？&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x,C-f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;打开文件&lt;/td&gt;
      &lt;td&gt;file&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x,b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;切换 Buffer&lt;/td&gt;
      &lt;td&gt;switcher&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x,k&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;关闭当前文件&lt;/td&gt;
      &lt;td&gt;close&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-_&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;撤销&lt;/td&gt;
      &lt;td&gt;undo&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-_&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;重做&lt;/td&gt;
      &lt;td&gt;redo&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-w&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;剪切&lt;/td&gt;
      &lt;td&gt;kill selected&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-w&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;复制&lt;/td&gt;
      &lt;td&gt;save to kill ring&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-y&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;粘帖&lt;/td&gt;
      &lt;td&gt;paste&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-y&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;粘帖历史选择&lt;/td&gt;
      &lt;td&gt;paste from history&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-S-↑/↓&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动当前行&lt;/td&gt;
      &lt;td&gt;move line up/down&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-S-↑/↓&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;移动当前语句/代码块&lt;/td&gt;
      &lt;td&gt;move statement up/down&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;注释当前行&lt;/td&gt;
      &lt;td&gt;line comment&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-:&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;注释块&lt;/td&gt;
      &lt;td&gt;block comment&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;展开&lt;/td&gt;
      &lt;td&gt;expand&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-M-=&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;全部展开&lt;/td&gt;
      &lt;td&gt;expand all&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C--&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;收缩&lt;/td&gt;
      &lt;td&gt;collapse&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-M--)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;全部收缩&lt;/td&gt;
      &lt;td&gt;collapse all&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Android Studio 对分割窗格的支持，基本可以做到和 Emacs 一致，除了 &lt;code&gt;C-x, 0&lt;/code&gt;，在 Android Studio 中它的行为与 &lt;code&gt;C-x, k&lt;/code&gt; 一致。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, 1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;关闭其他窗格&lt;/td&gt;
      &lt;td&gt;unsplit&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, 2&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;平行分割当前窗格&lt;/td&gt;
      &lt;td&gt;split&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, 3&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;竖直分割当前窗格&lt;/td&gt;
      &lt;td&gt;split&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, 0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;关闭当前窗格&lt;/td&gt;
      &lt;td&gt;unsplit&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, o&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;切换不同窗格&lt;/td&gt;
      &lt;td&gt;goto next spliteer&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;查找find&quot;&gt;查找（Find）&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;C-D&lt;/code&gt; 是 Dash 插件的默认快捷键，用于在 Dash/Velocity/Zeal 中搜索&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;文本内搜索/下一个匹配&lt;/td&gt;
      &lt;td&gt;find next&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-r&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;下一个匹配&lt;/td&gt;
      &lt;td&gt;find previous&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;替换&lt;/td&gt;
      &lt;td&gt;replace&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-S&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;全局搜索&lt;/td&gt;
      &lt;td&gt;find in path&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-R&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;全局替换&lt;/td&gt;
      &lt;td&gt;replace in path&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-S&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;查找使用&lt;/td&gt;
      &lt;td&gt;find usage&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-D&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Dash 中搜索&lt;/td&gt;
      &lt;td&gt;Search in Dash&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Android Studio 支持宏功能，默认的宏操作都没有配置快捷键，不过没有 &lt;code&gt;C-u&lt;/code&gt; 宏的实用性大打折扣&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, (&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;开始宏录制&lt;/td&gt;
      &lt;td&gt;start macro&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, )&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;停止宏录制&lt;/td&gt;
      &lt;td&gt;stop macro&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, e&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;运行宏&lt;/td&gt;
      &lt;td&gt;play last macro&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;编码code&quot;&gt;编码（Code）&lt;/h3&gt;

&lt;p&gt;重构的 Extract 都被绑定为 &lt;code&gt;C-M-key&lt;/code&gt;，本来也是不错的选择，可惜太多冲突，我改为 &lt;code&gt;Esc,key&lt;/code&gt;，取首字母相同来助记。前缀键我在 &lt;code&gt;Esc&lt;/code&gt; 和 &lt;code&gt;C-c&lt;/code&gt; 间犹豫了下，显然 &lt;code&gt;C-c&lt;/code&gt; 效率更好，但我觉得重构的话，在操作前有个停顿思考下也不是坏事。所以最终选择了 &lt;code&gt;Esc&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C-M&lt;/code&gt; 的默认功能与 &lt;code&gt;C-[&lt;/code&gt;、&lt;code&gt;C-]&lt;/code&gt; 重叠了，所以不如绑定为显示方法的参数信息，毕竟 Android Studio 的代码补全不支持显示方法参数，所以这个功能也是很有必要的。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-/&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;代码补全，按两次能显示更多选项&lt;/td&gt;
      &lt;td&gt;completion&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-M-/&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;代码补全，智能类型&lt;/td&gt;
      &lt;td&gt;completion&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-enter&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示建议行为，类是 quick fix&lt;/td&gt;
      &lt;td&gt;show intention actions&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-q&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;快速文档&lt;/td&gt;
      &lt;td&gt;quick document&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-I&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;快速显示定义&lt;/td&gt;
      &lt;td&gt;quick definition&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-P&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示当前表达式返回类型&lt;/td&gt;
      &lt;td&gt;expression type&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-M&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示方法参数信息&lt;/td&gt;
      &lt;td&gt;parameter info&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;格式化&lt;/td&gt;
      &lt;td&gt;reformat code&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, r&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;重命名&lt;/td&gt;
      &lt;td&gt;rename&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, i&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;优化 imports&lt;/td&gt;
      &lt;td&gt;optimize imports&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, j&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;插入在线模板，代码补全也支持补全模板&lt;/td&gt;
      &lt;td&gt;insert live template&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, g&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;生成代码&lt;/td&gt;
      &lt;td&gt;generate&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, s&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;生成包围代码&lt;/td&gt;
      &lt;td&gt;surround with&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;Esc, f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;提取为字段&lt;/td&gt;
      &lt;td&gt;field&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;Esc, c&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;提取为常量&lt;/td&gt;
      &lt;td&gt;constant&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;Esc, m&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;提取为方法&lt;/td&gt;
      &lt;td&gt;method&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;Esc, p&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;提取为参数&lt;/td&gt;
      &lt;td&gt;parameter&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;Esc, v&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;提取为变量&lt;/td&gt;
      &lt;td&gt;variable&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;运行make&quot;&gt;运行（Make）&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;S-F10&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;运行当前配置&lt;/td&gt;
      &lt;td&gt;run&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;S-F9&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;调试当前配置&lt;/td&gt;
      &lt;td&gt;debug&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-S-F9&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;运行当前 Activity&lt;/td&gt;
      &lt;td&gt;run context configuraton&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-S-F10&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;弹出运行选择菜单&lt;/td&gt;
      &lt;td&gt;run&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-S-F9&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;弹出调试选择菜单&lt;/td&gt;
      &lt;td&gt;debug&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;git&quot;&gt;Git&lt;/h3&gt;

&lt;p&gt;大部分 Vcs 相关的快捷键默认配置都和上面的配置冲突了，考虑到用于跳转的 &lt;code&gt;M-g&lt;/code&gt; 前缀键只用了 3 个，我的 VCS 只用 git
 一个，所以把 git 相关操作用 &lt;code&gt;M-g&lt;/code&gt; 前缀键重新编排下。因为很少用到，可能不太合理，一些 git 的基本操作我都是都是直接在 Shell 里输入。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g, +&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;add 当前文件&lt;/td&gt;
      &lt;td&gt;add to vcs&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g, C-c&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;commit&lt;/td&gt;
      &lt;td&gt;commit&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g, C-z&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;revert&lt;/td&gt;
      &lt;td&gt;revert&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g, C-f&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;fetch&lt;/td&gt;
      &lt;td&gt;fetch&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g, C-u&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;push&lt;/td&gt;
      &lt;td&gt;push&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g, C-a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;annotate&lt;/td&gt;
      &lt;td&gt;annotate&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g, C-p&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;pull&lt;/td&gt;
      &lt;td&gt;pull&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g, C-d&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;比较文件，在历史记录窗体可直接对比&lt;/td&gt;
      &lt;td&gt;compare file/show diff&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g, C-D&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;弹出比较文件浮窗&lt;/td&gt;
      &lt;td&gt;compare with&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g, C-h&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示当前文件历史&lt;/td&gt;
      &lt;td&gt;show history&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-g, C-H&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;显示当前选择区域历史&lt;/td&gt;
      &lt;td&gt;show history&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;鼠标mouse&quot;&gt;鼠标（Mouse）&lt;/h3&gt;

&lt;p&gt;某些情况鼠标还是比键盘更高效&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;Button2&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;矩形选择&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-S-Button1&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;放置多个光标&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;live-plugin&quot;&gt;Live-plugin&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/dkandalov/live-plugin&quot;&gt;live-plugin&lt;/a&gt; 是一个强大的插件，能给 Android Studio 提供类似 elisp 的运行环境及解析器，通过 groovy 脚本在运行时更改 IDE 的行为，所谓的 &lt;a href=&quot;http://martinfowler.com/bliki/InternalReprogrammability.html&quot;&gt;InternalReprogrammability&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我将其运行当前插件的快捷键更改为 Emacs 中执行 elisp 表达式的快捷键。其他的我还没有深入使用，只是写了个脚本用来实现单词首字母大写功能，并将其绑定到 &lt;code&gt;M-c&lt;/code&gt;，见 &lt;a href=&quot;https://github.com/douo/douo_config/tree/master/android-studio/live-plugin/capitalizeWord&quot;&gt;capitalizeWord&lt;/a&gt;。原理主要是&lt;code&gt; registerAction&lt;/code&gt; 来增加自定义 action，自定义的 action 能绑定快捷键，也能通过 find action 来搜索十分方便。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;快捷键&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;自定义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, C-e&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;运行当前插件&lt;/td&gt;
      &lt;td&gt;run current plugin&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;C-x, C-t&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;测试当前插件&lt;/td&gt;
      &lt;td&gt;test current plugin&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code&gt;M-c&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;单词首字母大写&lt;/td&gt;
      &lt;td&gt;captilazie word&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;*&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;这只是我常用的或偶尔用到的快捷键的罗列，不是完整的 Android Studio 快捷键说明，还有很多 Android Studio 的基本功能没有涉及到，记下来只是为了备忘和分享。这份快捷键会持续变更，可在 &lt;a href=&quot;https://github.com/douo/douo_config/tree/master/android-studio&quot;&gt;douo_keymaps&lt;/a&gt; 查看最新的配置。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://spin.atomicobject.com/2014/08/07/intellij-emacs/&quot;&gt;Customizing IntelliJ for Emacs Compatibility&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="Android Studio" /><category term="Emacs" /><category term="快捷键" /><category term="productive" /><summary type="html">Emacs 风格的快捷键通过前缀键来扩展更多打字区的快捷键，尽量把快捷键控制在打字键区，显著减少编码过程手腕的移动，是个经得起考验的快捷键方案（非 emacs 用户可能深痛恶觉）。 这套快捷键在 Emacs keymaps 的基础上进行自定义，首先减少对功能键区的使用，一来容易与系统快捷键冲突，二来手指移动的幅度过大难定位不容形成肌肉记忆，所以只保留编译运行相关的快捷键。至于编辑键区则更次，手腕必须得移动，眼睛也得跟着辅助定位，只保留少部分不常用的默认快捷键。数字键区最糟，手腕移动幅度最大，再说我的 87 键盘都没有小键盘-_-，直接弃用。至于鼠标，那更是万恶之源，整个手臂都得移动，还要眼睛配合才能用鼠标完成一次操作，写代码的过程大多是用鼠标辅助点击几次，然后又回到打字区继续敲，这样来回一次切换成本太高。何况程序员经常用鼠标点点点？多没 B 格啊。虽说如此，不过想要完全不用鼠标还是不太容易，只能说一个命令通过鼠标打开层层菜单来执行超过一次，第二次就应该用 Find Action 来执行，如果一天超过三次那就应该给它设个快捷键并记住。 Android Studio 相比 Eclipse 内置的 Emacs keymaps 强大了许多，不过 Eclipse 有 Emacs+， Android Studio 却没有这方面的插件。所有 Android Studio 相比 Emacs 多了一些不足，比如： Android Studio 只支持一个前缀键（prefix key），所以 spacemacs 那样的助记法快捷键 Android Studio 难以实现 Android Studio 中 Esc 不能作为修饰键使用 IntelliJ 可以为 Escape 命令配置快捷键，但不少 UI 还是硬编码为键盘的 Esc 键。所以为了退出浮窗，经常要 C-g、Esc 交替使用 不过窗口的操作逻辑不一致，有些 UI 可以用移动光标快捷键，有些只能用方向键 一些约定先说明，特别是非 Emacs 党： C = Control/Ctrl，如果小指还想要请将 CapsLock 改成 Ctrl M = Meta = Alt != Options S = Shift C-F 等同于 C-S-f ，无换档字符仍使用 C-S-key 表示 方向用图标表示：←、→、↑、↓ , 用于分隔前缀键，表示先按 , 前的键，松开，再按下一个键 关于 Mac 的 Options 键，参考：osx - How to disable option key to type greek letter in Mac OS? - Stack Overflow 最终使用的前缀键有下面三个： C-x Esc M-g 首先，最基本又最重要的键肯定就是 Find Action，简直就是 Emacs 中的 Run Command，必须绑定为 M-x。别的快捷键记不住不要紧，只要记住这个还是能做到无鼠标操作，特别是还附带快捷键提示，如果有的话。不过还是得对命令的关键字有点概念，表格中的关键字项就是表示通过该关键字在 Find Action 或者 Keymaps 设置搜索到相应功能；自定义有 * 表示快捷键是我自定义的，非 Emacs Keymaps 的默认配置。 快捷键 功能 关键字 自定义 M-x 执行命令 find Action * C-g 取消 escape   C-M-s 打开设置 settings   光标移动（Move cursor） 光标移动类的快捷键，这里指的是在单一文本的内的光标移动，又包括语法无关的移动和语法相关的移动，语法无关的移动指的就是光标的上下左右移动等等，这一块与 Emacs 基本一致。另外 C-l虽然不是移动光标，但也是放在这里。 快捷键 功能 关键字 自定义 C-f 向前移动一个字符 right   C-b 向后移动一个字符 left   C-n 向上移动一行 up   C-p 向下移动一行 down   M-f 向前移动一个单词 next word   M-b 向后移动一个单词 previous word   C-a 移动到行头 line start   C-e 移动到行尾 line end   C-v 下一页 page down   M-v 上一页 page up   M-&amp;lt; 移动到文本头 text start   M-&amp;gt; 移动到文本尾 text end   C-l 将光标位置滚动到屏幕中央 scroll to center   C-Pgup 移动到当前页的起始处 Page Top   C-PgDn 移动到当前页的结束处 page end   语法相关的移动： 快捷键 功能 关键字 自定义 C-[ 移动到当前 Block 起始大括号处 Code block start   C-] 移动到当前 BLock 结束大括号处 Code Block End   C-M-a 移动到前一个方法 previous method   C-M-e 移动到后一个方法 next method   Android Studio 将 M-g 作为跳转到行数，我改其作为前置键，同时作为跳转高亮错误的前置键。 快捷键 功能 关键字 自定义 M-g g 作为跳转到行数 line * M-g n 下一个高亮问题 next highlighted error * M-g p 上一个高亮问题 next highlighted error * 与光标相关的还有文本选择，我保留 C-space 来加入选择模式，但这个快捷键也常被操作系统用来切换输入法， 在 Linux 下我把输入切换配置为 Win-space，其他系统我也建议想办法把 C-space 留给 Android Studio。 快捷键 功能 关键字 自定义 C-space 切换选择模式 sticky selection   C-x, h 全选 select all   特别是 Android Studio 不像 emacs 可以用 C-F 等进行选择。只能用传统的 S-→。所以保留 C-space 还是有必要的，下面是例外： 快捷键 功能 关键字 自定义 C-{ 选择到当前 Block 起始大括号处 Code block start   C-} 选择到当前 Block 结束大括号处 Code block end   C-S-PgUp 选择到当前页的起始处 page start   C-S-PgDn 选择到当前页的结束处 page end   C-S-Home 选择到当前文本的起始处 text start   C-S-End 选择到当前文本的结束处 text end   导航（Navigate） 导航，在不同文件中切换。常用的导航我用一段式快捷键。一定要善用前三个，对编码效率绝对是很大的提高，起码不会让切换文件的速度脱慢你的思路。 C-M-G 是 C-M-g 的高级版，直接从实例名跳转到其类中。 快捷键 功能 关键字 自定义 C-M-f 上一个位置 forward * C-M-b 下一个位置 back * C-M-g 跳转到定义处 declaration   C-M-G 跳转到类型 type declaration * C-M-u 跳转到父类方法 super method * M-←/→ 左右切换标签 select tab   如果对简洁有要求或者屏幕太小（比如我），可以将 Android Studio 的标签关掉，具体参考：Configuring Behavior of the Editor Tabs，那么这时 M-←/→ 就不会起作用了。 另外 M-num 都被 Android Studio 绑定到切换功能窗体，很实用但不一一罗列了，比较常用的是 M-6 打开 Android Monitor、M-7 打开 Structure，至于 Project 有更好的快捷键打开。 C-num 用于跳转书签。C-M-num 则用于设置书签，书签是全局的。 Select in… 可谓的鼠标杀手中的 MVP，多少鼠标操作就是为了在其他窗体中操作当前文件。大部分情况下它都是比 M-num 更好的选择。默认的 Alt+F1 与系统冲突，我修改为 Esc，S-i，好记，不过需要前缀键确实难为了这个命令。 快捷键 功能 关键字 自定义 Esc,S-i 在其它窗体中选择，比如在项目窗体定位当前文件 select in.. * S-Esc 隐藏工具窗口，配合上个命令使用更佳。 Hide Active ToolWindow   C-S-Esc 隐藏所有工具窗口 Hide All ToolWindow * 编辑（Edit） 看快捷键说明， Android Studio 有 kill ring 的概念，比如 M-w、C-w、M-d、M-backspace 都是操作 kill ring，但是居然没有 yank pop，所以 M-y 只能绑定为不太实用 paste from history…，话说你把 kill ring 藏到哪了？ 快捷键 功能 关键字 自定义 C-x,C-f 打开文件 file   C-x,b 切换 Buffer switcher   C-x,k 关闭当前文件 close   C-_ 撤销 undo   M-_ 重做 redo   C-w 剪切 kill selected   M-w 复制 save to kill ring   C-y 粘帖 paste   M-y 粘帖历史选择 paste from history   M-S-↑/↓ 移动当前行 move line up/down   C-S-↑/↓ 移动当前语句/代码块 move statement up/down   M-; 注释当前行 line comment   M-: 注释块 block comment * C-= 展开 expand   C-M-= 全部展开 expand all * C-- 收缩 collapse   C-M--) 全部收缩 collapse all * Android Studio 对分割窗格的支持，基本可以做到和 Emacs 一致，除了 C-x, 0，在 Android Studio 中它的行为与 C-x, k 一致。 快捷键 功能 关键字 自定义 C-x, 1 关闭其他窗格 unsplit   C-x, 2 平行分割当前窗格 split   C-x, 3 竖直分割当前窗格 split   C-x, 0 关闭当前窗格 unsplit   C-x, o 切换不同窗格 goto next spliteer   查找（Find） C-D 是 Dash 插件的默认快捷键，用于在 Dash/Velocity/Zeal 中搜索 快捷键 功能 关键字 自定义 C-s 文本内搜索/下一个匹配 find next   C-r 下一个匹配 find previous   M-% 替换 replace   C-S 全局搜索 find in path * C-R 全局替换 replace in path   M-S 查找使用 find usage   C-D Dash 中搜索 Search in Dash * Android Studio 支持宏功能，默认的宏操作都没有配置快捷键，不过没有 C-u 宏的实用性大打折扣 快捷键 功能 关键字 自定义 C-x, ( 开始宏录制 start macro   C-x, ) 停止宏录制 stop macro   C-x, e 运行宏 play last macro   编码（Code） 重构的 Extract 都被绑定为 C-M-key，本来也是不错的选择，可惜太多冲突，我改为 Esc,key，取首字母相同来助记。前缀键我在 Esc 和 C-c 间犹豫了下，显然 C-c 效率更好，但我觉得重构的话，在操作前有个停顿思考下也不是坏事。所以最终选择了 Esc。 C-M 的默认功能与 C-[、C-] 重叠了，所以不如绑定为显示方法的参数信息，毕竟 Android Studio 的代码补全不支持显示方法参数，所以这个功能也是很有必要的。 快捷键 功能 关键字 自定义 M-/ 代码补全，按两次能显示更多选项 completion   C-M-/ 代码补全，智能类型 completion   M-enter 显示建议行为，类是 quick fix show intention actions   C-q 快速文档 quick document   C-I 快速显示定义 quick definition   C-P 显示当前表达式返回类型 expression type   C-M 显示方法参数信息 parameter info * C-x, f 格式化 reformat code * C-x, r 重命名 rename * C-x, i 优化 imports optimize imports * C-x, j 插入在线模板，代码补全也支持补全模板 insert live template * C-x, g 生成代码 generate * C-x, s 生成包围代码 surround with * Esc, f 提取为字段 field * Esc, c 提取为常量 constant * Esc, m 提取为方法 method * Esc, p 提取为参数 parameter * Esc, v 提取为变量 variable * 运行（Make） 快捷键 功能 关键字 自定义 S-F10 运行当前配置 run   S-F9 调试当前配置 debug   C-S-F9 运行当前 Activity run context configuraton   M-S-F10 弹出运行选择菜单 run   M-S-F9 弹出调试选择菜单 debug   Git 大部分 Vcs 相关的快捷键默认配置都和上面的配置冲突了，考虑到用于跳转的 M-g 前缀键只用了 3 个，我的 VCS 只用 git 一个，所以把 git 相关操作用 M-g 前缀键重新编排下。因为很少用到，可能不太合理，一些 git 的基本操作我都是都是直接在 Shell 里输入。 快捷键 功能 关键字 自定义 M-g, + add 当前文件 add to vcs * M-g, C-c commit commit * M-g, C-z revert revert * M-g, C-f fetch fetch * M-g, C-u push push * M-g, C-a annotate annotate * M-g, C-p pull pull * M-g, C-d 比较文件，在历史记录窗体可直接对比 compare file/show diff * M-g, C-D 弹出比较文件浮窗 compare with * M-g, C-h 显示当前文件历史 show history * M-g, C-H 显示当前选择区域历史 show history * 鼠标（Mouse） 某些情况鼠标还是比键盘更高效 快捷键 功能 关键字 自定义 Button2 矩形选择     M-S-Button1 放置多个光标     Live-plugin live-plugin 是一个强大的插件，能给 Android Studio 提供类似 elisp 的运行环境及解析器，通过 groovy 脚本在运行时更改 IDE 的行为，所谓的 InternalReprogrammability。 我将其运行当前插件的快捷键更改为 Emacs 中执行 elisp 表达式的快捷键。其他的我还没有深入使用，只是写了个脚本用来实现单词首字母大写功能，并将其绑定到 M-c，见 capitalizeWord。原理主要是 registerAction 来增加自定义 action，自定义的 action 能绑定快捷键，也能通过 find action 来搜索十分方便。 快捷键 功能 关键字 自定义 C-x, C-e 运行当前插件 run current plugin * C-x, C-t 测试当前插件 test current plugin * M-c 单词首字母大写 captilazie word * 总结 这只是我常用的或偶尔用到的快捷键的罗列，不是完整的 Android Studio 快捷键说明，还有很多 Android Studio 的基本功能没有涉及到，记下来只是为了备忘和分享。这份快捷键会持续变更，可在 douo_keymaps 查看最新的配置。 参考 Customizing IntelliJ for Emacs Compatibility</summary></entry><entry><title type="html">Android 项目打包到 JCenter 的坑</title><link href="http://dourok.info/2015/05/09/trouble-of-publish-aar/" rel="alternate" type="text/html" title="Android 项目打包到 JCenter 的坑" /><published>2015-05-09T00:00:00+00:00</published><updated>2018-09-27T07:53:40+00:00</updated><id>http://dourok.info/2015/05/09/trouble-of-publish-aar</id><content type="html" xml:base="http://dourok.info/2015/05/09/trouble-of-publish-aar/">&lt;p&gt;搜索下如何发布 Android 项目的信息，大部分都会找到这篇文章 &lt;a href=&quot;https://www.virag.si/2015/01/publishing-gradle-android-library-to-jcenter/&quot;&gt;Publishing Gradle Android Library to jCenter Repository&lt;/a&gt;，中文的指引可以看&lt;a href=&quot;http://zhengxiaopeng.com/2015/02/02/%E4%BD%BF%E7%94%A8Gradle%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%E5%88%B0JCenter%E4%BB%93%E5%BA%93/&quot;&gt;使用Gradle发布项目到JCenter仓库&lt;/a&gt;。不过，如果按照这些文章提供的 &lt;code&gt;build.gradle&lt;/code&gt;，可能还会遇到一些坑。&lt;/p&gt;

&lt;h3 id=&quot;调用-getbootclasspath-出错&quot;&gt;调用 getBootClassPath() 出错&lt;/h3&gt;

&lt;p&gt;具体的错误信息是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cannot call getBootClasspath() before setTargetInfo() is called.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是 gradle 的 android plugin 1.1.0 版本的 bug，见 &lt;a href=&quot;(https://code.google.com/p/android/issues/detail?id=152811)&quot;&gt;Issue 152811 - android - Android Gradle Plugin 1.1.0 breaks Javadoc tasks&lt;/a&gt;。将插件更新到 1.1.1 以上版本就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;classpath 'com.android.tools.build:gradle:1.1.2'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;gbk-编码问题&quot;&gt;GBK 编码问题&lt;/h3&gt;

&lt;p&gt;Windows 用户可能会遇到这个问题，因为你将文件设置为 UTF-8 编码，javadoc 默认的是系统编码，Windows 就是 GBK 编码。所以一旦 java 文件中出现中文注释就会报错，提示&lt;code&gt;无法映射的GBK编码&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这个很容易解决，为 javadoc 指明编码就可以。在 gradle 可以这么做： &lt;code&gt;options.encoding = &quot;utf-8&quot;&lt;/code&gt;，具体的任务代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;task javadoc(type: Javadoc) {
	...
    options.encoding = &quot;utf-8&quot;
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;javadoc-的依赖问题&quot;&gt;javadoc 的依赖问题&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;task javadoc(type: Javadoc) {
    source = android.sourceSets.main.java.srcDirs
    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文章中的 &lt;code&gt;javadoc&lt;/code&gt; 任务是这样的，重点在 classpath 那一行，这一行的意思是添加 Android 框架到 &lt;code&gt;javadoc&lt;/code&gt; 的 classpath 中。不过，如果你的项目使用了其他第三方依赖，那 &lt;code&gt;javadoc&lt;/code&gt; 任务很可能会执行失败的，因为上面的代码并没有这些添加第三方依赖到 classpath 中。比如我的项目，有下面这些依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.google.code.gson:gson:2.3.1'
    compile 'com.android.support:gridlayout-v7:22.1.1'
    compile 'com.android.support:support-v4:22.1.1'
    compile 'com.android.support:appcompat-v7:22.1.1'
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跑起上面的 &lt;code&gt;javadoc&lt;/code&gt; 就会报错，类似下面的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	xxxx.java:20: 错误: 找不到符号
    public static &amp;lt;T&amp;gt; T create(JsonElement json, Class&amp;lt;T&amp;gt; classOfModel) {
                               ^
  符号:   类 JsonElement
  位置: 类 xxxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时最简单的方法就是把第三方依赖加入 classpath：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; classpath += project.files(configurations.compile.files,android.getBootClasspath().join(File.pathSeparator))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是仍然报错&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error:Could not find com.android.support:gridlayout-v7:22.1.1.
Searched in the following locations:
USER_HOME/.m2/repository/com/android/support/gridlayout-v7/22.1.1/gridlayout-v7-22.1.1.pom
USER_HOME/.m2/repository/com/android/support/gridlayout-v7/22.1.1/gridlayout-v7-22.1.1.jar
https://jcenter.bintray.com/com/android/support/gridlayout-v7/22.1.1/gridlayout-v7-22.1.1.pom
https://jcenter.bintray.com/com/android/support/gridlayout-v7/22.1.1/gridlayout-v7-22.1.1.jar
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时我的 repositories 是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;allprojects {
    repositories {
        mavenLocal()
        jcenter()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找不到 support 库，因为 support 库是 sdk 下载下来的，所以在这两个位置找不到也很正常。Android Plugin 自带的任务执行起来却不会报错，想必是做了特殊处理。&lt;/p&gt;

&lt;p&gt;sdk 目录下也有个 maven repository，就是那些 support libs 所在的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ANDROID_HOME\extras\android\m2repository
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加进去再试一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Properties properties = new Properties()
properties.load(project.rootProject.file('local.properties').newDataInputStream()) // local.properties 有 sdk 的绝对位置
allprojects {
    repositories {
        maven {
            url properties.getProperty(&quot;sdk.dir&quot;)+&quot;/extras/android/m2repository&quot;
        }
        mavenLocal()
        jcenter()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;依然报错，这次是找到那些库了，但因为 sdk 目录下的库是 aar 格式的，javadoc 不支持。所以问题到这里近乎无解了，幸好我在 stackoverflow 找到另一个 &lt;a href=&quot;http://stackoverflow.com/a/24026735/851344&quot;&gt;android 生成 javadoc 的方法&lt;/a&gt;。稍加改写就可以生成 javadoc 为 maven 所用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android.libraryVariants.all { variant -&amp;gt;
    println variant.javaCompile.classpath.files
    if(variant.name == 'release') { //我们只需 release 的 javadoc
        task(&quot;generate${variant.name.capitalize()}Javadoc&quot;, type: Javadoc) {
            // title = ''
            // description = ''
            source = variant.javaCompile.source
            classpath = files(variant.javaCompile.classpath.files, project.android.getBootClasspath())
            options {
                encoding &quot;utf-8&quot;
                links &quot;http://docs.oracle.com/javase/7/docs/api/&quot;
                linksOffline &quot;http://d.android.com/reference&quot;, &quot;${android.sdkDirectory}/docs/reference&quot;
            }
            exclude '**/BuildConfig.java'
            exclude '**/R.java'
        }
        task(&quot;javadoc${variant.name.capitalize()}Jar&quot;, type: Jar, dependsOn: &quot;generate${variant.name.capitalize()}Javadoc&quot;) {
            classifier = 'javadoc'
            from tasks.getByName(&quot;generate${variant.name.capitalize()}Javadoc&quot;).destinationDir
        }
        artifacts {
            archives tasks.getByName(&quot;javadoc${variant.name.capitalize()}Jar&quot;)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以 support-v4 为例，&lt;code&gt;configurations.compile&lt;/code&gt; 和 &lt;code&gt;variant.javaCompile.classpath&lt;/code&gt; 打印出来的位置是不同的，分别是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;SDK_HOME\extras\android\m2repository\com\android\support\support-v4\22.1.1\support-v4-22.1.1.aar&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;PROJECT_HOME/MODULE/build/intermediates/exploded-aar/com.android.support/support-v4/22.1.1/jars/libs/internal_impl-22.1.1.jar&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看来 Android Plugin 确实有特殊处理。生成 javadoc 没问题其他的也基本没有什么问题，最终的 &lt;code&gt;build.gradle&lt;/code&gt; 见 &lt;a href=&quot;https://gist.github.com/douo/ef1856415c461953d3c1&quot;&gt;gist&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;关于 javadoc 的坑写得十分啰嗦，主要是想和大家分享一些 gradle 的使用经验，其实 gradle 并不困难，主要是 Android Plugin 缺乏文档又鲜有例子，所以折腾起来比较难受。Android Plugin 的用户指南是在 &lt;a href=&quot;https://sites.google.com/a/android.com/tools/tech-docs/new-build-system&quot;&gt;New Build System&lt;/a&gt; 而 DSL 文档则是在 &lt;a href=&quot;https://developer.android.com/tools/building/plugin-for-gradle.html&quot;&gt;Android Plug-in for Gradle&lt;/a&gt; 右边有个下载 DSL 文档按钮。Gradle 可看官方的用户指南 &lt;a href=&quot;http://gradle.org/docs/current/userguide/userguide&quot;&gt;Gradle User Guide&lt;/a&gt;，我还有一个&lt;a href=&quot;/notes/tools/gradle/&quot;&gt;乱糟糟的笔记&lt;/a&gt; 这个不足为看了。&lt;/p&gt;

&lt;p&gt;如何上传到 JCenter 这个按照一开始提及文章的操作应该是没什么问题的，反正我没遇到问题，成功上传了 &lt;a href=&quot;https://github.com/douo/lru-image&quot;&gt;lru-image&lt;/a&gt;。其实，不用上传到 jcenter 单单运行 &lt;code&gt;install&lt;/code&gt; 任务， gradle 会在 maven 的本地仓库中生成工件（artifact），只需将 mavenLocal 添加到 repositories，我们可以像发布到 JCenter 一样引用自己的库，方便打包那些多个项目共享又不想发布的私有库。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;allprojects {
    repositories {
        mavenLocal()
        jcenter()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;java-8-doclint-导致打包失败&quot;&gt;Java 8 doclint 导致打包失败&lt;/h3&gt;

&lt;p&gt;把下面代码加入 build.gradle 后面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (JavaVersion.current().isJava8Compatible()) {
    allprojects {
        tasks.withType(Javadoc) {
            options.addStringOption('Xdoclint:none', '-quiet')
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;见 &lt;a href=&quot;http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html&quot;&gt;Stephen Colebourne’s blog: Turning off doclint in JDK 8 Javadoc&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="coder" /><category term="android" /><category term="gradle" /><category term="jcenter" /><category term="maven" /><summary type="html">搜索下如何发布 Android 项目的信息，大部分都会找到这篇文章 Publishing Gradle Android Library to jCenter Repository，中文的指引可以看使用Gradle发布项目到JCenter仓库。不过，如果按照这些文章提供的 build.gradle，可能还会遇到一些坑。 调用 getBootClassPath() 出错 具体的错误信息是 Cannot call getBootClasspath() before setTargetInfo() is called. 这个是 gradle 的 android plugin 1.1.0 版本的 bug，见 Issue 152811 - android - Android Gradle Plugin 1.1.0 breaks Javadoc tasks。将插件更新到 1.1.1 以上版本就可以了。 classpath 'com.android.tools.build:gradle:1.1.2' GBK 编码问题 Windows 用户可能会遇到这个问题，因为你将文件设置为 UTF-8 编码，javadoc 默认的是系统编码，Windows 就是 GBK 编码。所以一旦 java 文件中出现中文注释就会报错，提示无法映射的GBK编码。 这个很容易解决，为 javadoc 指明编码就可以。在 gradle 可以这么做： options.encoding = &quot;utf-8&quot;，具体的任务代码如下： task javadoc(type: Javadoc) { ... options.encoding = &quot;utf-8&quot; ... } javadoc 的依赖问题 task javadoc(type: Javadoc) { source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) } 文章中的 javadoc 任务是这样的，重点在 classpath 那一行，这一行的意思是添加 Android 框架到 javadoc 的 classpath 中。不过，如果你的项目使用了其他第三方依赖，那 javadoc 任务很可能会执行失败的，因为上面的代码并没有这些添加第三方依赖到 classpath 中。比如我的项目，有下面这些依赖： dependencies { compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.google.code.gson:gson:2.3.1' compile 'com.android.support:gridlayout-v7:22.1.1' compile 'com.android.support:support-v4:22.1.1' compile 'com.android.support:appcompat-v7:22.1.1' } 跑起上面的 javadoc 就会报错，类似下面的错误： xxxx.java:20: 错误: 找不到符号 public static &amp;lt;T&amp;gt; T create(JsonElement json, Class&amp;lt;T&amp;gt; classOfModel) { ^ 符号: 类 JsonElement 位置: 类 xxxx 这时最简单的方法就是把第三方依赖加入 classpath： classpath += project.files(configurations.compile.files,android.getBootClasspath().join(File.pathSeparator)) 但是仍然报错 Error:Could not find com.android.support:gridlayout-v7:22.1.1. Searched in the following locations: USER_HOME/.m2/repository/com/android/support/gridlayout-v7/22.1.1/gridlayout-v7-22.1.1.pom USER_HOME/.m2/repository/com/android/support/gridlayout-v7/22.1.1/gridlayout-v7-22.1.1.jar https://jcenter.bintray.com/com/android/support/gridlayout-v7/22.1.1/gridlayout-v7-22.1.1.pom https://jcenter.bintray.com/com/android/support/gridlayout-v7/22.1.1/gridlayout-v7-22.1.1.jar ... 这时我的 repositories 是这样的： allprojects { repositories { mavenLocal() jcenter() } } 找不到 support 库，因为 support 库是 sdk 下载下来的，所以在这两个位置找不到也很正常。Android Plugin 自带的任务执行起来却不会报错，想必是做了特殊处理。 sdk 目录下也有个 maven repository，就是那些 support libs 所在的位置。 ANDROID_HOME\extras\android\m2repository 加进去再试一下 Properties properties = new Properties() properties.load(project.rootProject.file('local.properties').newDataInputStream()) // local.properties 有 sdk 的绝对位置 allprojects { repositories { maven { url properties.getProperty(&quot;sdk.dir&quot;)+&quot;/extras/android/m2repository&quot; } mavenLocal() jcenter() } } 依然报错，这次是找到那些库了，但因为 sdk 目录下的库是 aar 格式的，javadoc 不支持。所以问题到这里近乎无解了，幸好我在 stackoverflow 找到另一个 android 生成 javadoc 的方法。稍加改写就可以生成 javadoc 为 maven 所用： android.libraryVariants.all { variant -&amp;gt; println variant.javaCompile.classpath.files if(variant.name == 'release') { //我们只需 release 的 javadoc task(&quot;generate${variant.name.capitalize()}Javadoc&quot;, type: Javadoc) { // title = '' // description = '' source = variant.javaCompile.source classpath = files(variant.javaCompile.classpath.files, project.android.getBootClasspath()) options { encoding &quot;utf-8&quot; links &quot;http://docs.oracle.com/javase/7/docs/api/&quot; linksOffline &quot;http://d.android.com/reference&quot;, &quot;${android.sdkDirectory}/docs/reference&quot; } exclude '**/BuildConfig.java' exclude '**/R.java' } task(&quot;javadoc${variant.name.capitalize()}Jar&quot;, type: Jar, dependsOn: &quot;generate${variant.name.capitalize()}Javadoc&quot;) { classifier = 'javadoc' from tasks.getByName(&quot;generate${variant.name.capitalize()}Javadoc&quot;).destinationDir } artifacts { archives tasks.getByName(&quot;javadoc${variant.name.capitalize()}Jar&quot;) } } } 以 support-v4 为例，configurations.compile 和 variant.javaCompile.classpath 打印出来的位置是不同的，分别是 SDK_HOME\extras\android\m2repository\com\android\support\support-v4\22.1.1\support-v4-22.1.1.aar PROJECT_HOME/MODULE/build/intermediates/exploded-aar/com.android.support/support-v4/22.1.1/jars/libs/internal_impl-22.1.1.jar 看来 Android Plugin 确实有特殊处理。生成 javadoc 没问题其他的也基本没有什么问题，最终的 build.gradle 见 gist。 关于 javadoc 的坑写得十分啰嗦，主要是想和大家分享一些 gradle 的使用经验，其实 gradle 并不困难，主要是 Android Plugin 缺乏文档又鲜有例子，所以折腾起来比较难受。Android Plugin 的用户指南是在 New Build System 而 DSL 文档则是在 Android Plug-in for Gradle 右边有个下载 DSL 文档按钮。Gradle 可看官方的用户指南 Gradle User Guide，我还有一个乱糟糟的笔记 这个不足为看了。 如何上传到 JCenter 这个按照一开始提及文章的操作应该是没什么问题的，反正我没遇到问题，成功上传了 lru-image。其实，不用上传到 jcenter 单单运行 install 任务， gradle 会在 maven 的本地仓库中生成工件（artifact），只需将 mavenLocal 添加到 repositories，我们可以像发布到 JCenter 一样引用自己的库，方便打包那些多个项目共享又不想发布的私有库。 allprojects { repositories { mavenLocal() jcenter() } } Java 8 doclint 导致打包失败 把下面代码加入 build.gradle 后面： if (JavaVersion.current().isJava8Compatible()) { allprojects { tasks.withType(Javadoc) { options.addStringOption('Xdoclint:none', '-quiet') } } } 见 Stephen Colebourne’s blog: Turning off doclint in JDK 8 Javadoc</summary></entry><entry><title type="html">手伤回顾</title><link href="http://dourok.info/2014/09/05/ulna-styloid-process-fracture-after-a-month/" rel="alternate" type="text/html" title="手伤回顾" /><published>2014-09-05T00:00:00+00:00</published><updated>2017-01-13T15:18:50+00:00</updated><id>http://dourok.info/2014/09/05/ulna-styloid-process-fracture-after-a-month</id><content type="html" xml:base="http://dourok.info/2014/09/05/ulna-styloid-process-fracture-after-a-month/">&lt;p&gt;这是写于上个月的日记：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;八月五号晚和朋友一起踩单车，从东里到隆都再到莲下，最后出国道324再回家，本来没想踩这么远，在东里踩了一段后，发现再继续只有这条路线而已，往回踩又没意思，于是只能继续硬着头皮踩下去。&lt;/p&gt;

  &lt;p&gt;大概是因为侥幸心理作遂，朋友有带手电，我便不想带了。&lt;/p&gt;

  &lt;p&gt;隆都那段路路况并不好，偶尔一段路面凹陷，避开了几处，还是有一处避不开，因为没有手电看不清路面，高速（20多）压过去，结果后胎被蛇咬了。泄风不快，不过跑了一段后还是停下来打算换胎。因为随身带的内胎是18/23，而后胎是25的，最后还是决定补胎为好，折腾了一段时间才补好继续上路。&lt;/p&gt;

  &lt;p&gt;爆胎是其一，真正悲剧是发生在隆都到莲下那段路，一开始路况很糟糕且不说。后面的路面是极好的，因为刚修好，还没有通车。我便开始放松了起来，不自觉速度也快了，不过最多就是二十多，因为一直跟着山地后面。变换下姿势，因为觉得架子比较小，身体伸展不开，便把手放到最远端，手掌朝下按住手变顶部，没留神自己居然这个压到手刹上了，结果车轮抱死，只记得前轮好像打横了，其他还没反应过来整个人就飞出去了，可能是左手先着地，伤得最严重，接着是右手侧身落地，肘关节肿起一块，肩膀在地上磨了一小段，起了一块红点，肌肉痛，幸好衣服没破。右脚膝盖也磨掉一小块皮。&lt;/p&gt;

  &lt;p&gt;起来后发现左手腕动不了，手腕还得放在大腿上支撑，不然痛得不行，剩下的路程只能一只手骑了，十多公里还是坚持下来了。快到的时候发现还被补了一刀，本来车子无大碍，就是手变被磨伤了，结果回来的路上把 cateye 码表弄丢了，估计是在等红灯的时候，一只手上下车很吃力，试了好几次，估计在那里蹭掉了。本来那个红灯可以不等的…看来人生的戏剧性就是体现在这样接二连三的悲剧中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当时还不知道这次受伤的严重性。隔天看了一个私人的中医推拿接骨医生，还拍了片，医生一开始说可能骨头裂了，看了一下片又说没有大碍，还说两次就能好，听到医生这样说确实心里轻松了很多，自觉还是挺幸运的。接下来两次推拿换药后，但疼痛对比一开始确实有所减轻，不过还是很痛，没有像医生所说的那样好了。月底刚好有朋友要结婚，以为到时应该能好，便兴奋地先把车票订了。第三次去才开始发现情况有些不对，疼痛没有继续减轻，&lt;strong&gt;最糟糕的是手腕没有办法&lt;a href=&quot;http://www.innerbody.com/image/musc03.html&quot;&gt;旋后（supination）&lt;/a&gt;，也就是没办法将掌心朝上，正常人的手腕起码可以转动 270° 以上，我的伤手只能转 100° 左右&lt;/strong&gt;。医生一开始说是因为包住了没法转，可拆掉纱布我还是转不了，这时医生才改口说没那么容易好，要继续包。我也只能半信半疑继续听从医生，一开始我想当然以为是关节没按好导致旋转障碍的，便打算给医生按多几次，希望可以按好。可以一次接一次，症状还是没有改善，医生说来说去也说不n出所以然，就是重复地说没那么快好。&lt;/p&gt;

&lt;p&gt;发现手腕的旋转功能有问题后，这段时间我自己也在网上找资料，越找越担心，手腕是一个很复杂的关节，而手腕的受伤中，&lt;strong&gt;TFCC 损伤&lt;/strong&gt;和&lt;strong&gt;下尺桡关节脱位&lt;/strong&gt;，都是很容易被误诊漏诊的。而且错过急性期后，便很难恢复，得通过手术治疗而且恢复也不能保证。&lt;/p&gt;

&lt;p&gt;这时我才在忧心忡忡中决定换医生，问的是镇上一个有些名气的老医生。一开始还是期待能被他按上一下就能恢复功能，可惜这种奇迹没有发生，医生让我往各个动一下试试，然后又包起来，说如果接下来没有好转那下次换药就再去拍片。当然下次也没什么明显好转，便去医院拍片，拍完片后，影像科的结论是&lt;strong&gt;尺骨茎突骨折&lt;/strong&gt;，拿到片后吃了一惊，医院拍得片跟在私人拍的片那个分辨率差距太大了，医院拍的片可以看到在尺骨茎突有一段斜亮线，而私人拍的片着弥漫着一片模糊，连茎突都看不太清楚。难怪一开始的医生会说没有大碍。原来是骨折还被他这样推拿折腾，想想都会冒冷汗，这是一个&lt;strong&gt;很大的教训&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;老医生看了片后，也认为是尺骨茎突骨折，他的意见是保守治疗，先保护起来（用纸板包住，同时把手吊起来），让骨头愈合。我请教他为什么会不能旋后，他也不确定是骨折导致的，我又问他是不是三角纤维软骨复合体受伤，他也说有可能，这一损伤需要做核磁共振，不过他也没说下尺桡关节会有什么问题。找不到具体原因我也很担心，不过还是听从医生先保守治疗，耐心等待骨头愈合。对老医生我也觉得担忧，第一印象就是记忆力非常差，同样的问题要几分钟内会连续问上两三次，而且下次去换药的时候他还忘记了我上次有来过…&lt;/p&gt;

&lt;p&gt;到 9 月 5 号刚好一个月了，炎症已经减轻很多了，不动他也也基本不会痛了，但是手腕的旋后功能障碍依然没有任何改善，所以我开始担心了，保守治疗如果没有效果，接下来只能手术了，尺骨茎突骨折如果附带 TFCC 损伤，那便是很严重的了。&lt;/p&gt;

&lt;p&gt;9 月 10 号刚好过去五周，再去找医生换药，医生说时间差不多了可以不用保护了，接下来贴膏药，吃药丸，熏药汤就可以。我告诉他手腕还是不能旋后，他拿起我两只手试了一下，发现左手不能转过去，这时才说，这样确实有问题，好像才刚知道我的手不能旋后一样，怎么一开始来的时候没有做这个测试，我觉很无奈。后来，他想了一下，给了我本市一个知名专家的电话，叫我联系他让他帮忙检查。&lt;/p&gt;

&lt;p&gt;当晚我便联系了专家，简单说明情况后，专家问我受伤多久了，听到五周后，便说很麻烦，还重复了几次，让我明天去找他当面说明情况。听到医生这样说，可谓百感交集啊。拆掉纱布，才能好好地看清楚我的左手，对比了右手，发现两手明显有不同，左手尺骨的突出比右手高出一些，医生怎么没发现呢，怎么不考虑下是下尺桡关节脱位呢，再加上刚才专家的话，真的是越想越气愤，难道真的中彩了，要开刀的话，真不知道要埋怨谁。&lt;/p&gt;

&lt;p&gt;今天去了医院和专家,也就是&lt;a href=&quot;http://www.haodf.com/doctor/DE4r0BCkuHzdeKoRgkJtvC5s9enjZ.htm&quot;&gt;邱主&lt;/a&gt;见了面，交流了下后，他让我拍了左手肘，左手腕，和右手腕，看了片他说骨头没什么问题，对比了左右手的下尺桡关节，左手的关节有间隙，而右手的下尺桡关节明显是靠在一起的，他的意见是说那里的韧带有点松，可能是这个原因导致的，因为没有确诊我便问他，进一步检查的意见，是否要做MRI，他说这个位置做 MRI 也没什么意思，要确诊得去做关节镜，汕头没有，得去广州。最后他认为这个问题，不算太严重，觉得没必要开刀，还是理疗为主（用护腕圈住）。听到邱主的结论，可以说有点失望吧，因为还是没有找到原因。不过专家说没有大问题，心情还是轻松了不少。专家还是很好人的，下午似乎是因为我才特意过来医院的。晚上回家后，自己硬掰了几下，发现旋转的角度有大了一点，希望以后继续掰可以慢慢恢复吧。&lt;/p&gt;

&lt;p&gt;戏剧性地是原本没什么问题的右手腕，拍片后发现，「尺骨茎突旁见小骨块影，性质待定」…没什么不舒服就暂且不起管它吧，单纯尺骨茎突骨折是可以不用治疗的。&lt;/p&gt;

&lt;p&gt;流水账般记录了这一个月的经历，若说教训的话，也是老调重弹了，便是受伤千万不能大意，去设备专业的医院检查，以免耽误了治疗的时间，悲伤的是误诊仍不能避免，只能降低概率，看来经过这一次对小诊所医生又多了一种不可靠的感觉。不过想深一下医生也没什么过错，主要是检查方面的大意。这段时间了解了很多相关知识，还整理了一些&lt;a href=&quot;/notes/quick/2014/09/note-2014-09-06&quot;&gt;笔记&lt;/a&gt;。现在，过了「&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%96%AA%E6%85%9F&quot;&gt;哀悼週期&lt;/a&gt;」，已经淡然。&lt;/p&gt;

&lt;p&gt;另一个教训便是骑行的姿势，特别是手的位置，这样放完成是作死。还有装备一定一要带全买全，去了医院才知道那钱真不叫钱。对比起来一开始为装备付出的那些钱真不算什么。一寸短一寸险，保护措施要做足，学会防御性骑车。&lt;/p&gt;

&lt;p&gt;一年后，手腕的旋转角度已经恢复正常了（可能病因是关节粘连吧），一开始三个月有注意锻炼，后来也没怎么理了。现在旋转到尽头后再用力尺骨末端会有酸痛感（两手都会，伤手严重点），仍不敢手掌托着地面来做俯卧撑。&lt;/p&gt;

&lt;p&gt;期间，膝盖又出问题了（可能是髌骨软骨软化），用力就痛，肌肉萎缩，伤腿的大腿比健侧瘦了一圈，去做了 MRI，看了运动医学医生，还做了康复治疗。当然一年后的现在都好了不少了，单车继续骑。推荐这个专栏&lt;a href=&quot;http://zhuanlan.zhihu.com/sportsmedicine&quot;&gt;运动医学 - 知乎专栏&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="life" /><category term="骨折" /><category term="骑行" /><summary type="html">这是写于上个月的日记： 八月五号晚和朋友一起踩单车，从东里到隆都再到莲下，最后出国道324再回家，本来没想踩这么远，在东里踩了一段后，发现再继续只有这条路线而已，往回踩又没意思，于是只能继续硬着头皮踩下去。 大概是因为侥幸心理作遂，朋友有带手电，我便不想带了。 隆都那段路路况并不好，偶尔一段路面凹陷，避开了几处，还是有一处避不开，因为没有手电看不清路面，高速（20多）压过去，结果后胎被蛇咬了。泄风不快，不过跑了一段后还是停下来打算换胎。因为随身带的内胎是18/23，而后胎是25的，最后还是决定补胎为好，折腾了一段时间才补好继续上路。 爆胎是其一，真正悲剧是发生在隆都到莲下那段路，一开始路况很糟糕且不说。后面的路面是极好的，因为刚修好，还没有通车。我便开始放松了起来，不自觉速度也快了，不过最多就是二十多，因为一直跟着山地后面。变换下姿势，因为觉得架子比较小，身体伸展不开，便把手放到最远端，手掌朝下按住手变顶部，没留神自己居然这个压到手刹上了，结果车轮抱死，只记得前轮好像打横了，其他还没反应过来整个人就飞出去了，可能是左手先着地，伤得最严重，接着是右手侧身落地，肘关节肿起一块，肩膀在地上磨了一小段，起了一块红点，肌肉痛，幸好衣服没破。右脚膝盖也磨掉一小块皮。 起来后发现左手腕动不了，手腕还得放在大腿上支撑，不然痛得不行，剩下的路程只能一只手骑了，十多公里还是坚持下来了。快到的时候发现还被补了一刀，本来车子无大碍，就是手变被磨伤了，结果回来的路上把 cateye 码表弄丢了，估计是在等红灯的时候，一只手上下车很吃力，试了好几次，估计在那里蹭掉了。本来那个红灯可以不等的…看来人生的戏剧性就是体现在这样接二连三的悲剧中。 当时还不知道这次受伤的严重性。隔天看了一个私人的中医推拿接骨医生，还拍了片，医生一开始说可能骨头裂了，看了一下片又说没有大碍，还说两次就能好，听到医生这样说确实心里轻松了很多，自觉还是挺幸运的。接下来两次推拿换药后，但疼痛对比一开始确实有所减轻，不过还是很痛，没有像医生所说的那样好了。月底刚好有朋友要结婚，以为到时应该能好，便兴奋地先把车票订了。第三次去才开始发现情况有些不对，疼痛没有继续减轻，最糟糕的是手腕没有办法旋后（supination），也就是没办法将掌心朝上，正常人的手腕起码可以转动 270° 以上，我的伤手只能转 100° 左右。医生一开始说是因为包住了没法转，可拆掉纱布我还是转不了，这时医生才改口说没那么容易好，要继续包。我也只能半信半疑继续听从医生，一开始我想当然以为是关节没按好导致旋转障碍的，便打算给医生按多几次，希望可以按好。可以一次接一次，症状还是没有改善，医生说来说去也说不n出所以然，就是重复地说没那么快好。 发现手腕的旋转功能有问题后，这段时间我自己也在网上找资料，越找越担心，手腕是一个很复杂的关节，而手腕的受伤中，TFCC 损伤和下尺桡关节脱位，都是很容易被误诊漏诊的。而且错过急性期后，便很难恢复，得通过手术治疗而且恢复也不能保证。 这时我才在忧心忡忡中决定换医生，问的是镇上一个有些名气的老医生。一开始还是期待能被他按上一下就能恢复功能，可惜这种奇迹没有发生，医生让我往各个动一下试试，然后又包起来，说如果接下来没有好转那下次换药就再去拍片。当然下次也没什么明显好转，便去医院拍片，拍完片后，影像科的结论是尺骨茎突骨折，拿到片后吃了一惊，医院拍得片跟在私人拍的片那个分辨率差距太大了，医院拍的片可以看到在尺骨茎突有一段斜亮线，而私人拍的片着弥漫着一片模糊，连茎突都看不太清楚。难怪一开始的医生会说没有大碍。原来是骨折还被他这样推拿折腾，想想都会冒冷汗，这是一个很大的教训。 老医生看了片后，也认为是尺骨茎突骨折，他的意见是保守治疗，先保护起来（用纸板包住，同时把手吊起来），让骨头愈合。我请教他为什么会不能旋后，他也不确定是骨折导致的，我又问他是不是三角纤维软骨复合体受伤，他也说有可能，这一损伤需要做核磁共振，不过他也没说下尺桡关节会有什么问题。找不到具体原因我也很担心，不过还是听从医生先保守治疗，耐心等待骨头愈合。对老医生我也觉得担忧，第一印象就是记忆力非常差，同样的问题要几分钟内会连续问上两三次，而且下次去换药的时候他还忘记了我上次有来过… 到 9 月 5 号刚好一个月了，炎症已经减轻很多了，不动他也也基本不会痛了，但是手腕的旋后功能障碍依然没有任何改善，所以我开始担心了，保守治疗如果没有效果，接下来只能手术了，尺骨茎突骨折如果附带 TFCC 损伤，那便是很严重的了。 9 月 10 号刚好过去五周，再去找医生换药，医生说时间差不多了可以不用保护了，接下来贴膏药，吃药丸，熏药汤就可以。我告诉他手腕还是不能旋后，他拿起我两只手试了一下，发现左手不能转过去，这时才说，这样确实有问题，好像才刚知道我的手不能旋后一样，怎么一开始来的时候没有做这个测试，我觉很无奈。后来，他想了一下，给了我本市一个知名专家的电话，叫我联系他让他帮忙检查。 当晚我便联系了专家，简单说明情况后，专家问我受伤多久了，听到五周后，便说很麻烦，还重复了几次，让我明天去找他当面说明情况。听到医生这样说，可谓百感交集啊。拆掉纱布，才能好好地看清楚我的左手，对比了右手，发现两手明显有不同，左手尺骨的突出比右手高出一些，医生怎么没发现呢，怎么不考虑下是下尺桡关节脱位呢，再加上刚才专家的话，真的是越想越气愤，难道真的中彩了，要开刀的话，真不知道要埋怨谁。 今天去了医院和专家,也就是邱主见了面，交流了下后，他让我拍了左手肘，左手腕，和右手腕，看了片他说骨头没什么问题，对比了左右手的下尺桡关节，左手的关节有间隙，而右手的下尺桡关节明显是靠在一起的，他的意见是说那里的韧带有点松，可能是这个原因导致的，因为没有确诊我便问他，进一步检查的意见，是否要做MRI，他说这个位置做 MRI 也没什么意思，要确诊得去做关节镜，汕头没有，得去广州。最后他认为这个问题，不算太严重，觉得没必要开刀，还是理疗为主（用护腕圈住）。听到邱主的结论，可以说有点失望吧，因为还是没有找到原因。不过专家说没有大问题，心情还是轻松了不少。专家还是很好人的，下午似乎是因为我才特意过来医院的。晚上回家后，自己硬掰了几下，发现旋转的角度有大了一点，希望以后继续掰可以慢慢恢复吧。 戏剧性地是原本没什么问题的右手腕，拍片后发现，「尺骨茎突旁见小骨块影，性质待定」…没什么不舒服就暂且不起管它吧，单纯尺骨茎突骨折是可以不用治疗的。 流水账般记录了这一个月的经历，若说教训的话，也是老调重弹了，便是受伤千万不能大意，去设备专业的医院检查，以免耽误了治疗的时间，悲伤的是误诊仍不能避免，只能降低概率，看来经过这一次对小诊所医生又多了一种不可靠的感觉。不过想深一下医生也没什么过错，主要是检查方面的大意。这段时间了解了很多相关知识，还整理了一些笔记。现在，过了「哀悼週期」，已经淡然。 另一个教训便是骑行的姿势，特别是手的位置，这样放完成是作死。还有装备一定一要带全买全，去了医院才知道那钱真不叫钱。对比起来一开始为装备付出的那些钱真不算什么。一寸短一寸险，保护措施要做足，学会防御性骑车。 一年后，手腕的旋转角度已经恢复正常了（可能病因是关节粘连吧），一开始三个月有注意锻炼，后来也没怎么理了。现在旋转到尽头后再用力尺骨末端会有酸痛感（两手都会，伤手严重点），仍不敢手掌托着地面来做俯卧撑。 期间，膝盖又出问题了（可能是髌骨软骨软化），用力就痛，肌肉萎缩，伤腿的大腿比健侧瘦了一圈，去做了 MRI，看了运动医学医生，还做了康复治疗。当然一年后的现在都好了不少了，单车继续骑。推荐这个专栏运动医学 - 知乎专栏</summary></entry></feed>