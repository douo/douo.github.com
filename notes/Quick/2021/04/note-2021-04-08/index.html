
<!DOCTYPE html>
<html class="borderbox" >
    
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>
    2021年04月08日杂记 | DouO's Note</title>
  <meta name="description" content="有時樹會倒下，某片天頃刻明亮
">

  <!-- Favicon -->
  <link rel="shortcut icon" href="/assets/images/favicon.ico" type="image/x-icon" />
  <!-- Windows 8 Tile Icons -->
  <meta name="application-name" content=" Blog">
  <meta name="msapplication-TileColor" content="#5d4d7a">
  <meta name="msapplication-square70x70logo" content="smalltile.png" />
  <meta name="msapplication-square150x150logo" content="mediumtile.png" />
  <meta name="msapplication-wide310x150logo" content="widetile.png" />
  <meta name="msapplication-square310x310logo" content="largetile.png" />
  <!-- Android Lolipop Theme Color -->
  <meta name="theme-color" content="#5d4d7a">
  <script src="/assets/main.js"></script>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  </head>

    <body>
        <header>
  <nav class="top-nav">
    <div class="container">
      <div class="nav-wrapper">
        <div class="row">
          <div class="col s12 m10 offset-m1">
            <h1 class="header">2021年04月08日杂记</h1>
          </div>
        </div>
      </div>
    </div>
  </nav>
  <div class="container"><a href="#" data-target="nav-mobile" class="top-nav sidenav-trigger full hide-on-large-only"><i class="material-icons">menu</i></a></div>
  <ul id="nav-mobile" class="sidenav sidenav-fixed">
    <li>
      <div class="logo">
        <a id="logo-container" href="/notes" class="brand-logo">
          <object id="front-page-logo" type="image/svg+xml">Your browser does not support SVG</object>
        </a>
        <div class="social">
          
          <a href="/rss.xml" title="订阅">
            <svg class="icon" aria-hidden="true">
              <use xlink:href="#icon-feed"></use>
            </svg>
          </a>
          
          <a href="https://github.com/douo" title="Github">
            <svg class="icon" aria-hidden="true">
              <use xlink:href="#icon-github"></use>
            </svg>
          </a>
          
          <a href="https://stackoverflow.com/users/851344/douo" title="StackOverflow">
            <svg class="icon" aria-hidden="true">
              <use xlink:href="#icon-stack-overflow"></use>
            </svg>
          </a>
          
          <a href="https://plus.google.com/102537448648560113422" title="Google Plus">
            <svg class="icon" aria-hidden="true">
              <use xlink:href="#icon-google-plus"></use>
            </svg>
          </a>
          
          <a href="https://instagram.com/douo" title="Instagram">
            <svg class="icon" aria-hidden="true">
              <use xlink:href="#icon-instagram"></use>
            </svg>
          </a>
          
        </div>
    </li>
    </div>
    <li class="search">
      <div class="search-wrapper">
        <input id="search" placeholder="Search"><i class="material-icons">search</i>
        <div class="search-results"></div>
      </div>
    </li>
    <li class="no-padding">
      <div id="blog-nav">
        <ul>
          
          <li><a href="/">主页</a></li>
          
          <li><a href="/notes">笔记</a></li>
          
          <li><a href="/categories#coder-ref">编码</a></li>
          
          <li><a href="/categories#life-ref">生活</a></li>
          
          <li><a href="/categories#otaku-ref">兴趣</a></li>
          
          <li><a href="/tags">标签</a></li>
          
          <li><a href="/log">日志</a></li>
          
          <li><a href="/help">帮助</a></li>
          
          <li><a href="/about">关于</a></li>
          
        </ul>
      </div>
      <div id="note-nav"></div>
    </li>
  </ul>
  <div id="nav-tab" class="hide-on-med-and-down">
    <div class="row">
      <ul class="tabs">
        <li class="tab col s6"><a href="#blog-nav">博客</a></li>
        <li class="tab col s6"><a href="#note-nav">笔记</a></li>
      </ul>
    </div>
  </div>
</header>
<!-- Page Layout here -->
<main><div class="container">
  <div class="row">

    <div class="content col s12 m8 offset-m1 xl7 offset-xl1"> <div class="post-meta">
<span class="post-date tooltipped" data-tooltip="最后更新 21-10-01">2021-04-08</span>
    
</div>

<article>
    <h1 id="资源">资源</h1>

<ul>
  <li>入口：http://gaia.cs.umass.edu/kurose_ross/</li>
  <li><a href="http://gaia.cs.umass.edu/kurose_ross/online_lectures.htm">视频</a></li>
</ul>

<p>数据包从发送端系统到接收端系统经过的通信链路和数据包交换的顺序称为通过网络的路由或路径。</p>

<p>PON(passive optical networks) ，无源光纤网络</p>

<p>电路交换（Circuit Switching），相当于需要预约的餐馆，用餐需要提前预约，到达后无需等待座位
包交换（Packet），用餐不需预约，到达后需要等待空桌</p>

<p>ISP 之间如何互相链接，低级 ISP 链接高级 ISP，最高级的 ISP 称为一级骨干网（tier-1 isp），高级 ISP 网络中供低级 ISP 接入的一组路由器称为 PoPs（Points of presence），低级 ISP 链接多个高级 ISP 称为 multi-homing。
同级 ISP 之间相互链接称为 Peer，多个ISP 互相 Peer 的节点称为 IXP。另外还有 Content Provider ，比如谷歌的 Content Provider 网络，之间的设备跨越全球，独立于互联网相互链接，同时向外提供互联网服务，也有接入各个层级的 ISP。</p>

<p>延迟
1节点通过路由发送数据包到另外一个节点时的延迟称为节点延迟（nodal delay），由四个延迟构成：</p>

<ol>
  <li>处理延迟（Processing），主要是路由检查数据包的标头并确定将数据包定向到何处，数量级微秒</li>
  <li>排队延迟（Queuing），排队等待发送到链路，数量级微秒到毫秒</li>
  <li>传输延迟（Transmission），基于分组转发的网络中，等到数据包接受完整才能转发（存储转发？），等于数据包大小除与传输速度，微秒到毫秒。</li>
  <li>传播延迟（Propagation），比特在链路中传播的时间，大概就是光速。</li>
</ol>

<p>排队延迟是最有趣与复杂的部分。</p>

<p>a 包每秒，L 包大小，R 传输速率。 La/R traffic intensity， TI 大于 1 时，队列会无限增长。</p>

<p>但队列满了，路由就会丢弃新的数据包。</p>

<p>吞吐（throughput），</p>

<p>作者将因特网分为 5 层</p>

<ol>
  <li>应用层，包称为 message</li>
  <li>传输层，包称为 segment</li>
  <li>网络层，包称为 datagrams，源和目标之间的一系列路由器来路由 datagram。</li>
  <li>链路层，包称为 frame，将 frame 从一个节点传播到另一个节点， Ethernet, WiFi 等</li>
  <li>物理层，包视为独立的位，</li>
</ol>

<h2 id="packet-sniffer">packet sniffer</h2>

<ol>
  <li>packet capture library，复制链路层的帧 （libpcap）</li>
  <li>packet analyzer</li>
</ol>

<h1 id="application">Application</h1>

<p>传输层提供给应用层的四个维度：</p>

<ol>
  <li>可靠，TCP</li>
  <li>吞吐，未能保证，实际可用</li>
  <li>时效，未能保证，实际可用</li>
  <li>安全，TLS（TLS 是在应用层实现的）</li>
</ol>

<h2 id="http">HTTP</h2>

<p>stateless protocol</p>

<p>RTT(round-trip time)</p>

<h3 id="header">HEADER</h3>

<p>HOST，预留给代理使用</p>

<h3 id="http2">HTTP/2</h3>

<p>HOL(Head of Line) blocking，持久链接的 http，所有请求用同一个链接，出现大对象传输阻塞了小对象传输，增加 UPD（user-perceived delay）。</p>

<p>HTTP/1.1 会并发多个 TCP 链接来解决 HOL。</p>

<p>HTTP/2 减少打开单个页面并发多个 TCP 链接的数量。</p>

<p>用 framing mechanism 来减少 UPD。大概的机制是每个对象都被分为大小相等数量不等的帧组，然后遍历每个帧组每次传输一个帧。</p>

<h2 id="email">EMail</h2>

<p>SMTP，邮件服务器之间的协议。只允许传输 7-bit ASCII，用于推送邮件
IMAP，客户端从邮件服务器获取邮件的协议</p>

<h2 id="dns">DNS</h2>

<p><a href="https://en.wikipedia.org/wiki/BIND">BIND</a></p>

<h2 id="p2p">P2P</h2>

<ul>
  <li>Peer 优先获取最稀有的 chunk，</li>
  <li>Peer 优先向传输率最高的 Peers 发送数据。最高的四个，称为 unchoked</li>
  <li>Peer 每 30s 会随机选择一个 Peer 发送数据，称为 optimistically unchoked</li>
</ul>

<p>DHT</p>

<h2 id="video-streaming--cdn">Video Streaming &amp; CDN</h2>

<h3 id="cdn">CDN</h3>

<ul>
  <li>私有 CDN，由内容提供者拥有</li>
  <li>第三方 CDN，为内容提供者提供服务</li>
</ul>

<p>服务放置哲学</p>

<ul>
  <li>Enter Deep，深入到每个 ISP部署集群（cluster），大量的服务器</li>
  <li>Bring Home，在 IXP中部署，更低的维护开销，更高的延迟，更低的吞吐量</li>
</ul>

<p>一次 CDN 请求：</p>
<ol>
  <li>用户向本地 DNS（LDNS） 请求 CDN 域名，</li>
  <li>LDNS 向权威DNS，请求域名</li>
  <li>权威DNS 向 LDNS NS 记录，指向 CND 域名的私有 DNS</li>
  <li>LDNS 向私有DNS 请求 CDN 域名</li>
  <li>私有DNS 根据集群选择策略返回 IP 地址</li>
  <li>LDNS 将地址返回给用户</li>
</ol>

<p>第五步，是 CDN 的关键，也就是集群选择策略（cluster selection strategy）：</p>

<ul>
  <li>基于 LDNS ip 地址的地理最近。问题：地理最近不见得，速度最快</li>
  <li>实时测量，集群周期性的测试（ping、dns 请求）与各个 LDNS 的线路，从中找出最优</li>
</ul>

<p>基于 LDNS 的策略都有一个问题，LDNS 不见得真的是<strong>本地</strong>，比如用户自定义为 <code>8.8.8.8</code>。ECS（edns-client-subnet）就是为了解决这个问题的，在 DNS 请求报文里加入原始请求的 IP，使得CDN能根据真正的用户信息返回正确的结果。</p>

<h1 id="transport-layer">Transport Layer</h1>

<p>传输层协议提供了在不同主机上运行的进程之间的逻辑通信，而网络层协议则提供了主机之间的逻辑通信。 这种区别是微妙的，但很重要。 让我们借助家庭类比来检验这种区别。</p>

<p>TCP</p>

<ol>
  <li>可靠性</li>
  <li>阻塞控制</li>
</ol>

<h2 id="multiplexing-and-demultiplexing">Multiplexing and Demultiplexing</h2>

<p>通过端口（port）实现</p>

<h2 id="udp">UDP</h2>

<p>UDP, defined in [RFC 768], does just about as little as a transport protocol can do. Aside from the multiplexing/demultiplexing function and some light error checking, it adds nothing to IP</p>

<ol>
  <li>可在应用层更精细的控制数据发送</li>
  <li>无需建立链接</li>
  <li>无链接状态</li>
  <li>更小的包头（TCP 20 bytes UDP 8 bytes）</li>
</ol>

<p>UDP segment 头</p>

<ol>
  <li>源 port</li>
  <li>目标 port</li>
  <li>length</li>
  <li>checksum</li>
</ol>

<p>checksum 是求所有 16bit word 的和（溢出的话，保留 16bit 再+1）的反码（1s complement）</p>

<h2 id="可靠数据传输">可靠数据传输</h2>

<ul>
  <li>比特翻转</li>
  <li>丢包</li>
</ul>

<p>有限状态机</p>

<p>ARQ (Automatic Repeat reQuest) protocols.</p>

<ul>
  <li>Error detection</li>
  <li>Receiver feedback  ACK(positive) NAK（NEGATIVE）</li>
  <li>Retransmission</li>
</ul>

<p>ACK/NAK 的重传</p>

<h3 id="pipelining">Pipelining</h3>

<ol>
  <li>Go-Back-N, 滑动窗口协议。要求包按顺序到达，乱序的包会被丢弃。 base 包超时或损坏会导致所有包都重传</li>
  <li>selective repeat，ACK 所有接受到的包，无需管顺序。每个包都要有计时器，reciever需要buffer。</li>
</ol>

<p>Extended finite-state machine</p>

<ul>
  <li>Checksum, 校验传输过程中的 bit 错误</li>
  <li>Timer，计算超时重传</li>
  <li>Sequence number，用于 pipeline 包传输</li>
  <li>ack， receiver 通知 sender 包被正确接受</li>
  <li>nak， 通知包没有被正确接收，未使用</li>
  <li>window,pipelining， 当前传输包的序列号范围</li>
</ul>

<h2 id="tcp">TCP</h2>

<p>MSS（maximum segment size）= MTU - TCP Header(typically 40 bytes)</p>

<p>Header</p>

<ul>
  <li>sequence number 32bit</li>
  <li>ack number 32bit</li>
  <li>receive window 16bit</li>
  <li>header length 4bit ，因为 options 不同头部是变长的</li>
  <li>options</li>
  <li>flag 6bit</li>
</ul>

<p>flag</p>

<ul>
  <li>CWR, 显式拥塞通知</li>
  <li>ECE, 显式拥塞通知</li>
  <li>URG, segment marked as <strong>urgent</strong></li>
  <li>ACK</li>
  <li>PSH，the receiver should pass the data to the upper layer immediately.</li>
  <li>RST</li>
  <li>SYN， setup</li>
  <li>FIN， teardown</li>
</ul>

<p>In practice, the PSH, URG, and the urgent data pointer are not used. However, we mention these fields for completeness.)</p>

<blockquote>
  <p>TCP only acknowledges bytes up to the first missing byte in the stream, TCP is said to provide cumulative acknowledgments.</p>
</blockquote>

<p>累计确认（cumulative acknowledgment）,发送方，收到确认 N ，代表 [N，base] 已经收到。接收方，失序的包不发送确认。</p>

<p>receiver 如何对待失序包(RFC 未做规定):</p>

<p>1.</p>

<p>TCP 是全双工， ACK 可以和数据包一起发送，称为 piggybacked</p>

<h3 id="rtt-与超时">RTT 与超时</h3>

<ul>
  <li>SampleRTT，一个 segment 发送到接收到 ACK 的时间</li>
  <li>EstimatedRTT，是多个 SampleRTT 的加权平均值</li>
</ul>

\[E_{rtt} = (1 - a)*E_{rtt} + a*S_{rtt}\]

<p>a 推荐取值 .125，代表最近一个 SampleRTT 的权重。统计学中称为 exponential weighted moving average</p>

<p>DevRTT, 表示 RTT 的变化，网络波动大值越大</p>

\[D_{rtt} = (1 - b)*PREV_D_{rtt} + b*|S_{rtt} - E_{rtt}|\]

<p>b 推荐取值 .25</p>

<p>超时的计算： \(E_{rtt} + 4* D_{rtt}\)</p>

<h3 id="可靠性">可靠性</h3>

<p>超时
快速重传，接收方接到3次重复 ACK，执行快速重传。</p>

<p>接收方发送 ACK 的策略：</p>

<ol>
  <li>接收到顺序包，同时没有其他待 ack 的包，等待 500ms 或新的顺序包再发</li>
  <li>接收到顺序包，存在顺序待 ack 包，立刻发送累计 ack 包（即是按新顺序的包发 ack）</li>
  <li>接收到失序包，立刻发送重复 ack</li>
  <li>接收到填充 gap 的包，立刻发送 ack（TODO 是最新的顺序还是当前接收的包，合理是最新顺序，接收ACK应该表示是其期望接收到的包）</li>
</ol>

<p>TCP的错误恢复机制可能最好归类为GBN和SR协议的混合体。</p>

<h3 id="流控制">流控制</h3>

<p>receive window，接收窗口用于使发送方了解接收方可用的可用缓冲区空间。</p>

<p>rwnd = RcvBuffer – [LastByteRcvd – LastByteRead]</p>

<p>发送方确保 LastByteSent – LastByteAcked &lt;= rwnd</p>

<h3 id="链接管理">链接管理</h3>

<p>建立链接</p>

<ol>
  <li>C 选择随机起始序列号然后向 S 发送 SYN</li>
  <li>S 接收到 SYN，S 初始化 buffer 和变量，选择随机序列号，发回 SYN ACK，</li>
  <li>C 接收到 SYN ACK，初始化 buffer 和变量，发回 ACK，这个 ACK 可带有负载。</li>
</ol>

<p>这就是三次握手</p>

<p>C 关闭链接</p>

<ol>
  <li>C 发送 FIN</li>
  <li>S 接收 FIN，发回 ACK，再发送 FIN</li>
  <li>C 接收到 ACK，等待 FIN</li>
  <li>C 接收到 FIN，发回 ACK。等待 30s C 清空资源</li>
  <li>S 接收 ACK，S 清空资源</li>
</ol>

<p>向端口未开放的 S 建立链接：</p>

<ol>
  <li>C 选择随机起始序列号然后向 S 发送 SYN</li>
  <li>S 接收到 SYN，S 发送 RST</li>
</ol>

<h2 id="阻塞控制">阻塞控制</h2>

<p>阻塞的代价：</p>
<ol>
  <li>排队延迟</li>
  <li>包重传</li>
  <li>包重复</li>
  <li>上游链路的工作被浪费</li>
</ol>

<p>网络层是否提供协助</p>

<p>指标：</p>
<ol>
  <li>丢包</li>
  <li>rtt 延迟</li>
</ol>

<h3 id="tcp-阻塞控制">TCP 阻塞控制</h3>

<p>如何限制速率：</p>

<p>congestion window, cwnd</p>

<p>LastByteSent – LastByteAcked … min{cwnd, rwnd}</p>

<p>如何发现阻塞？</p>

<ol>
  <li>丢包，超时或三次冗余ack，降低 cwnd</li>
  <li>ack，ack 到达表示网络通畅，可增加 cwnd</li>
  <li>带宽探测，增加 cwnd 直到丢包，然后降低 cwnd 直到不丢包，如此反复</li>
</ol>

<p>实现</p>

<ol>
  <li>慢启动
1 MSS 初始，收到 1 ACK 就增加一个 1MSS，理想状态下增长率就是 2^n
遇到超时丢包时会保存此时的 cwnd 后重启慢启动，同时设置限制（ssthresh）为 cwnd/2，增长到限制时，会进入阻塞回避模式
遇到三次冗余 ack，会执行快速重传然后进入快速恢复模式</li>
  <li>
    <p>阻塞回避，cwnd 变为线性增长，每次 rtt 只增长 1 MSS。遇到阻塞后行为与慢启动一致。</p>
  </li>
  <li>快速恢复（tcp reno）
接收到冗余 ACK，cwnd + 1MSS，正常 ACK 进入阻塞回避模式，cwnd 重置为ssthresh
超时，重启慢启动，ssthrest = cwnd / 2</li>
</ol>

<h3 id="tcp-cubic">TCP Cubic</h3>

<p>与 TCP RENO 的区别在于阻塞回避（congestion avoidance）</p>

<ul>
  <li>\(W_{max}\) 丢包时的 cwnd</li>
  <li>K，假设恢复到 \(W_{max}\) 所需的时间</li>
  <li>cube 函数，根据当前时间与 K 的距离计算 cwnd，越接近 K 增长越慢</li>
  <li>t 超过 K ，回先缓慢增长，离 K 越远增长越快</li>
</ul>

<p>Linux 默认使用 Cubic</p>

<p>TODO</p>

<h3 id="网络层阻塞控制">网络层阻塞控制</h3>

<h4 id="ecn-显式阻塞通知">ECN 显式阻塞通知</h4>

<p>IP datagram header 留 2 bits 用于 ECN。1 bit 表示阻塞，1bit 表示支持ECN。</p>

<p>接收者发现 ECN 阻塞时，会通知接收者，通过在 ACK 包设置 ECE。接收者 cwnd 减半，在下一个包同时设置 CWR</p>

<h4 id="基于延迟的阻塞控制">基于延迟的阻塞控制</h4>

<p>TCP Vegas，如果速率能达到 \(cwnd/RTT_{min}\)，则增长窗口，反之则减少窗口
TCP BBR，基于 TCP Vegas，并能与非 BBR 的公平竞争</p>

<h3 id="公平性">公平性</h3>

<p>应用程序建立更多 TCP 链接是能获得竞争优势的。</p>

<p>TCP 阻塞控制是根据链接数的相对平均的分配</p>

<p>这也许是多进程下载的优势</p>

<h3 id="其他传输层协议">其他传输层协议</h3>

<p>QUIC，应用层实现，基于 UDP，默认加密</p>

<ol>
  <li>整合握手与安全</li>
  <li>不同的数据流可以在一个包里传输</li>
  <li>TCP 友好阻塞控制，顺序保证基于流的，丢包出错不会影响到其他流</li>
</ol>

<h1 id="网络层">网络层</h1>

<p>网络层分为数据平面与控制平面</p>

<ul>
  <li>转发（forward）/交换（switch），本地路由，把一个包从输入链路传输到相应的输出链路</li>
  <li>路由，整个网络范围内，选择合适的路径将数据包传输到目标主机</li>
</ul>

<p>交换与转发是意思相近的属于，交换跟多用于链路层。</p>

<p>交换机指的是二层交换，路由是三层转发，会根据网络层数据包的头部来进行转发</p>

<p>输入端口：</p>

<ul>
  <li>物理层功能，终止物理线路</li>
  <li>链路层功能，与输入链路交互</li>
  <li>lookup function，转发表获取到包应该传输到哪个输出端口</li>
</ul>

<p>交换结构（switching fabric），连接输入端口与输出端口</p>

<p>路由处理器，执行控制平面的功能，维护路由表和连接链路信息等。SDN 路由器，中用来处理远端发送的控制信息。</p>

<p>输入输出端、交换结构一般都是硬件实现</p>

<h3 id="基于目的地的转发">基于目的地的转发</h3>

<p>When there are multiple matches, the router uses the longest prefix matching rule</p>

<p>输入端口处理</p>

<p>match + action</p>

<ul>
  <li>路由表匹配</li>
  <li>物理层链路层处理</li>
  <li>检查包版本、checksum、rtl 并更新</li>
  <li>计数器计数</li>
</ul>

<p>交换结构，</p>

<ul>
  <li>通过内存交换，传统计算机、软路由应该也是这样处理</li>
  <li>共享内存</li>
  <li>总线，交换过程通过标识来转发到特定输出端口，在输出端口移除标识恢复原始数据</li>
  <li>互联网络，同时能交换多个包</li>
</ul>

<p>输出端口处理，</p>

<p>接收交换结构的包，排队、调度包，链路层物理层处理，发送到线路终端</p>

<h3 id="排队">排队</h3>

<p>输出端口， drop-tail</p>

<p>缓存大小， B = RTT*C</p>

<p>buffering can be used to absorb short-term statistical fluctuations in traffic but can also lead to increased delay and the attendant concerns.</p>

<p>缓冲膨胀（bufferbloat）</p>

<p>包调度</p>

<p>WFQ，加权公平队列，数据包分为多个类别，每个类别有不同权重，循环传输每个类别的包，每个类别占用的带宽比等于权重。</p>

<h2 id="ip-协议">IP 协议</h2>

<p>datagram format</p>

<p>不含 options 的 header 长 20-bytes</p>

<p>碎片化，Id、flags、fragmentation offset，用于碎片化重组。IPv6 不允许碎片化</p>

<p>TTL，Time-to-live，限制 datagram 的传播次数。经过一次路由就 -1</p>

<p>Protocol，协议号。表示携带的传输层协议，相当于传输层的端口号。</p>

<p>checksum，为何TCP/IP 要各自校验一次？ IP datagram header 只能在 ip 层校验，而 TCP/IP 可以各自搭配不同的协议栈。TCP 不要求网络层一定要做好校验。</p>

<p>options，很少用，影响路由性能。 IPv6 取消了 options</p>

<h3 id="ip-地址">IP 地址</h3>

<p>IP地址在技术上与接口相关联，而不是与包含该接口的主机或路由器相关联。</p>

<p>A subnet is also called an IP network or simply a network in the Internet literature.</p>

<p>a.b.c.d/x，分为前x位称为网络部分，及 32-x 位称为子网部分。
CIRD之前，ip 地址的网络部分被限制为 8、16、24.分别对于 A、B、C级网络</p>

<p>C 类子网只有 256 台主机，B类子网有 65634 台主机。前者太少，后者太多。</p>

<p>地址聚合（address aggregation）</p>

<p>255.255.255.255 广播地址，发送到这个地址的包会在子网内广播。路由一般不会转发广播到其他子网</p>

<h3 id="dhcp">DHCP</h3>

<h2 id="nat">NAT</h2>

<p>基于 16位端口号做索引，所以最多支持60000+个连接</p>

<p>NAT traversal tools</p>

<p>路由是三层（网络层）设备，端口号是传输层（四层）的概念。NAT 破坏三层设备的原则。</p>

<h2 id="ipv6">IPv6</h2>

<ul>
  <li>128bits</li>
  <li>anycast（任播地址），允许数据报传递到任意一个主机组</li>
  <li>header 部定长 40-byte.</li>
  <li>ver 4bit</li>
  <li>traffic class， 8bit</li>
  <li>flow label，RFC 2460，标识是否是实时服务等。应该也是用于 qos。居然用了 20bit</li>
  <li>paload lenth,16bit</li>
  <li>Next header，相当于 ipv4 的 protocol</li>
  <li>Hop limit, 相当于 ttl</li>
  <li>s &amp; d addr 128bit*2</li>
</ul>

<p>取消了 checksum</p>

<h2 id="一般化转发">一般化转发</h2>

<p>match-plus-action</p>

<h2 id="中间盒middleboxes">中间盒（middleboxes）</h2>

<p>表示，在源主机和目标主机之间的数据路路径上执行除一般标准 ip 路由功能外的其他功能</p>

<ul>
  <li>nat</li>
  <li>防火墙，ids</li>
  <li>性能增强，内容缓存，加载均衡等</li>
</ul>

<h2 id="control-plane">Control-Plane</h2>

<ul>
  <li>转发表（forwarding table），基于目标的转发</li>
  <li>flow table，一般化转发</li>
</ul>

<p>如何控制路由如何转发：</p>

<ul>
  <li>路由间控制，路由与其他路由间通信计算各自的转发表。OSPF、BGP 协议</li>
  <li>本地中心控制，由一个中心服务器计算下发 flow table。 SDN</li>
</ul>

<h2 id="路由算法选路算法">路由算法/选路算法</h2>

<p>带权图 G = (N,E)中，找出最短路径</p>

<ul>
  <li>中心化路由算法，算法知道图的全部状态，节点、边、权重。 link-state (LS) algorithms</li>
  <li>去中心化路由算法，节点只知道自己的边和权重，通过节点间交互多次迭代。distance-vector (DV) algorithm</li>
</ul>

<p>路由算法还区分，静态和动态算法，静态表示图的结构几乎不变，由人手动改变。动态表示，路由路径会根据网络负载或拓扑而改变。</p>

<p>最后路由算法还区分是否负载敏感，负载敏感表示，链路（边）成本会随着负载情况动态变化。</p>

<h3 id="link-state-routing-algorithm">Link-State Routing Algorithm</h3>

<p>分为两步，如何知道图的全部状态？如何计算最短路径</p>

<ol>
  <li>节点广播 link-state 包到网络中的其他节点，直到节点获取真个网络的结构</li>
  <li>Dijkstra 最短寻路算法，计算当前节点到其他节点的最短路径</li>
</ol>

<h3 id="distancevector-routing-algorithm">Distance—Vector Routing Algorithm</h3>

<p>每个节点接收来自邻居节点的信息，计算并返回结果给邻居节点，迭代到无新的信息交换</p>

<p>节点间交换的信息，就是当前节点的 Distance-Vector：\(Dx:=[D_x(y):y in N]\)，\(D_x(y)\) 表示 x 到 y 的最短路径。 Bellman-Ford equation: \(D_x(y) = min_v{c(x,v) + D_v(y)}\)，v 是 x 的邻居。</p>

<pre><code>Initialization:
for all destinations y in N:
Dx(y)= c(x,y)/* if y is not a neighbor then c(x,y)= ∞ */
for each neighbor w
Dw(y) = ? for all destinations y in N
for each neighbor w
send distance vector Dx = [Dx(y): y in N] to w
loop
wait (until I see a link cost change to some neighbor w or
           until I receive a distance vector from some neighbor w)
for each y in N:
Dx(y) = minv{c(x,v) + Dv(y)}
if Dx(y) changed for any destination y
send distance vector Dx = [Dx(y): y in N] to all neighbors
forever
</code></pre>

<p>cost 变化可能导致 count-to-infinity problem</p>

<h3 id="ospfopen-shortest-path-first">OSPF(Open Shortest Path First)</h3>

<p>用于内部自治系统的路由协议（intra-autonomous system routing protocol），用的是 Link-state 算法。</p>

<p>Link-state 协议</p>

<h3 id="bgpborder-gateway-protocol">BGP（Border Gateway Protocol）</h3>

<p>自治系统间的路由协议，BGP 是 Internet 最重要的两个协议之一，另外一个是 IP 协议。</p>

<p>CIDRize Prefix， Ex：<code>138.16.68/22</code>，路由转发表的结构：(x,I)。 x prefix I 接口</p>

<p>BGP 提供给路由两个能力：</p>

<ol>
  <li>从邻居 ASs 获取 prefix 可达性的信息</li>
  <li>决定到 prefixes 的最佳路径</li>
</ol>

<p>如何发送 BGP 信息，ASn 的网关路由通过 eBGP 链接发送可达性信息到达 ASm 的网关路由，ASm 将信息通过 iBGP 链接发送给 ASm 内的其他路由。</p>

<p>BGP route：NEXT-HOP; AS- PATH; destination prefix：</p>

<pre><code>IP address of leftmost interface for router 2a; AS2 AS3; x
IP address of leftmost interface of router 3d; AS3; x
</code></pre>

<h4 id="ip-任播anycast">IP 任播（AnyCast）</h4>

<p>为不同服务器（地理上不同位置）设置相同 IP 地址，各个服务器通过标准 BGP 宣告这些 IP  地址。BGP 路由会自动选择最优化的路由到达目标 IP（不同服务器）。</p>

<p>IP 任播会导致同一个 TCP 链接的不同包，被发送到不同的服务器上。所以不太适合用于CDN，更适合于 DNS</p>

<h2 id="sdnsoftware-define-network">SDN(Software Define Network)</h2>

<ul>
  <li>data plane</li>
  <li>control plane，SDN Controller, SDN network-control apps</li>
</ul>

<p>SD-WAN</p>

<h3 id="icmp">ICMP</h3>

<ul>
  <li>ping</li>
  <li>traceroute</li>
</ul>

<h2 id="snmp">SNMP</h2>

<h1 id="link-layer">Link Layer</h1>

<p>link-layer channel</p>

<ol>
  <li>broadcast channel, 介质访问协议（ medium access protocol ）</li>
  <li>point-to-point communication link, Point-to-Point Protocol (PPP)</li>
</ol>

<p>Possible services link-layer provided</p>

<ul>
  <li>framing, datagram to frame</li>
  <li>link access, 介质访问控制协议（MAC），决定哪个 frame 在 link 传输</li>
  <li>reliable delivery，高出错率的link才会提供，比如 wireless，低出错率的电缆光纤没必要提供。交给上层。</li>
  <li>Error detection and correction，需要链路层协议都有提供，以为出错的datagram 没有传输的必要</li>
</ul>

<p>the link layer is implemented on a chip called the network adapter, also sometimes known as a network interface controller (NIC).</p>

<p>the link layer is a combination of hardware and software</p>

<p>软件部分，实现组装链路层寻址信息，激活控制器等。</p>

<h2 id="error-detection--correction">Error Detection &amp; Correction</h2>

<p>EDC bits，不是 100% 有效</p>

<ul>
  <li>parity checks</li>
  <li>checksumming</li>
  <li>CRC(cyclic redundancy check)</li>
</ul>

<h3 id="parity-checking奇偶验证">Parity Checking（奇偶验证）</h3>

<p>新增一位 Parity Bit，当 Frame 中的 1 为偶数时为0，反之为 1</p>

<p>二维 parity，将数据排列成行列式，每行每列都有一位 parity bit。出现一个位翻转时还能纠错。</p>

<p>前向纠错，The ability of the receiver to both detect and correct errors is known as forward error correction (FEC)</p>

<h3 id="checksumming">Checksumming</h3>

<p>把 frame 的位当作 k 位的整数序列，最简单的校验和就是把所以序列中的整数相加得到的。</p>

<p>传输层协议 TCP &amp; UDP 用的就是校验和。链路层用的是 CRC，校验和比 CRC 保护性更弱。为什么传输层要用校验和？因为传输层是在软件实现的，需要简单快速错误检测算法。链路层是硬件 CRC。</p>

<h3 id="crccyclic-redundancy-check">CRC(cyclic redundancy check)</h3>

<h4 id="有限域">有限域</h4>

<p>GF，有限个元素，进行加减乘除运算都有定义并且满足特定规则的集合。
满足域的定义</p>

<ul>
  <li>非空集合</li>
  <li>有加法和乘法，对这两个运算封闭</li>
  <li>满足交换律、结合律、分配率</li>
  <li>加法零元和负元，乘法有幺元和逆元</li>
</ul>

<p>最常见的有限域例子就是整数模素数p，如果p不是素数的话，两个非零元（p的因数）相乘可以等于零元。这个非零元不存在逆元，不满足域的定义。</p>

<p>通信编码常见的有限域是 GF(2^m)，表示 m 个二进制位的序列，运算后模2 在每个位上进行。</p>

<p>加法就是异或。</p>

<p>多项式码，就是把 GF(2^m)当成m次多项式的系数。</p>

<ul>
  <li>加法就是同次的项相加，再模2，结果等同于异或。</li>
  <li>乘法，同样将两个多项式按普通运算相乘，结果再模本原多项式</li>
  <li>本原多项式P(X)，一般通过查表可得，可见求解不容易（满足系数不可约,整除x^(2m)+1,不能整除,x^k+1,k=1…2^m-2），有多个，GF(2^m) 的最高项一定是 x^m。</li>
  <li>多项式取模就是按位异或</li>
</ul>

<p>以 GF(2^8) 为例，取本原多项式 P(x) = x^8+x^4+x^3+x^2+1。那么 x^8 mod P(x) = P(x) - x^8 = x^4+x^3+x2+1</p>

<p>一般形式 f(x) = a7<em>x^7+…..a1</em>x+a0, x<em>f(x) =(a7</em>x^8+….a1<em>x^2+a0</em>x)mod P(x) ，若 a7 = 1，则需要代入 x^8 mod P(x)</p>

<h4 id="crc">CRC</h4>

<ul>
  <li>待生成的长度 d 的位序列为 D</li>
  <li>生成多项式为 G，G 的最高位系数必须为 1 ，的长度为 r+1</li>
  <li>D/G，得出余数 R，r 是 R 的最长长度</li>
  <li>D 最低位补上 r bits 0 与 R 异或，得出 D‘，长度为 d+r</li>
  <li>D‘ 能被 G 整除，异或相当于减法</li>
</ul>

<p>D‘ = D*2r XOR R = nG</p>

<p>发送方发送 D’，接收方只需校验 D’ 能否被 G 整除便可以验错。</p>

<p>CRC-n 的 n 表示的是 G 的长度</p>

<ul>
  <li>CRC 标准可以检测小于 r + 1 位的突发错误。</li>
  <li>大于 r+1 位的错误的检出率是 1-0.5^r</li>
  <li>可以检验任何奇数位的错误</li>
</ul>

<h2 id="multiple-access-links-and-protocols">Multiple Access Links and Protocols</h2>

<ul>
  <li>P2P links, PPP 协议、HDLC</li>
  <li>broadcast link，集线器</li>
</ul>

<p>Multple Access Protocols，多节点在广播链路上通信的协议，重点在于如何解决冲突</p>

<p>假设广播链路的带宽位R bps</p>

<ul>
  <li>只有一个节点在发送时，吞吐应该达到 R bps</li>
  <li>有 M 个节点，每个节点的平均吞吐应该位 R/M bps</li>
  <li>去中心化，避免 SPOF</li>
</ul>

<p>协议分类</p>

<ul>
  <li>channel partitioning</li>
  <li>random access</li>
  <li>taking-turns</li>
</ul>

<h3 id="channel-partitioning">channel partitioning</h3>

<p>TDM，为每个节点分配一个时间帧，无论是否需要收发数据
FDM，在带宽为 R 的频段中划分 R/N 的频段，也是平均划分。
CDMA，每个节点使用特殊的标识码来编码数据，不同的节点可以同时传输，并且它们各自的接收器可以正确接收发送器的编码数据位</p>

<h3 id="random-access-protocols">Random Access Protocols</h3>

<p>各个节点全速发送数据，遇到冲突后，等待一个随机时间再重传。</p>

<p>Slotted ALOHA</p>

<ul>
  <li>节点时间同步</li>
  <li>L bits 帧大小，R bps 信道传输速度</li>
  <li>每 L/R 秒为一个 Slot</li>
  <li>Slot 开始的时候，节点才可以发送数据帧</li>
  <li>冲突的话，节点会在在一个 Slot 以 p 概率重传数据帧</li>
  <li>协议效率是 1/e = 0.37 R bps</li>
</ul>

<p>ALOHA</p>

<ul>
  <li>效率是 1/2e，因为在数据帧的传输时间窗口内，之前传输的帧可能重叠。</li>
</ul>

<p>CSMA</p>

<ul>
  <li>carrier sensing， Listen before speaking</li>
  <li>collision detection，If someone else begins talking at the same time, stop talking.</li>
</ul>

<p>出现冲突使用 binary exponential backoff ，避免再次冲突</p>

<h3 id="taking-turns-protocols">Taking-Turns Protocols</h3>

<p>Polling protocol</p>

<ul>
  <li>消除碰撞和空槽</li>
  <li>增加polling 延迟</li>
  <li>需要一个 master node</li>
</ul>

<p>token-passing protocol</p>

<ul>
  <li>令牌环</li>
</ul>

<h3 id="docsis">DOCSIS</h3>

<ul>
  <li>使用 FDM 来区分上行、下行</li>
  <li>上行流量使用 TDM</li>
  <li>CMTS 终端显式分配时间</li>
  <li>节点通过 request frame 告知 CMTS 需要上行</li>
  <li>request frame 使用 random acess 协议，碰撞用 binary exponential backoff</li>
</ul>

<h2 id="交换局域网">交换局域网</h2>

<p>交换机并没有链路层地址，交换机对于设备来说是透明的。</p>

<h3 id="mac">MAC</h3>

<ul>
  <li>6-byte， 2^48</li>
  <li>前 24 位由 IEEE 分配</li>
</ul>

<blockquote>
  <p>Although MAC addresses were designed to be permanent, it is now possible to change an adapter’s MAC address via software.</p>
</blockquote>

<ul>
  <li>广播地址 FF-FF-FF-FF-FF-FF</li>
</ul>

<p>目标主机只接收目标地址位自身或广播地址的数据帧</p>

<h3 id="arp">ARP</h3>

<p>ARP 只在同一子网中工作</p>

<p>host/router 都维护则一个 ARP 表，字段包括 IP、 MAC、TTL</p>

<p>ARP packet，srcIP、dstIP、srcMac、dstMac（应该是广播地址）。发送给链路层广播地址。</p>

<p>ARP 模块检测 ARP packet，如果 dstIP 是本机的话，则响应 ARP packet，到目标主机（原发送主机）</p>

<p>ARP 查询是广播帧，ARP 响应是普通帧</p>

<p>ARP 可能最好被视为跨链路和网络层之间边界的协议</p>

<h3 id="以太网ethernet">以太网（Ethernet）</h3>

<ul>
  <li>集线器（hub），位级别的广播，两个接口同时接收到 bits 会冲突，用 CDMA/CD 协议解决 MAC</li>
  <li>交换机（switch），存储转发帧，无冲突，无须 MAC 协议</li>
</ul>

<p>数据帧结构</p>

<pre><code>Preamble Dst Src Type Data CRC
</code></pre>

<ul>
  <li>Data，MTU 1500 byts，最小传输是 46 bytes，低于 46 会被填充，网络层协议需要根据 length 来读取数据。</li>
  <li>Dst，6 bytes Mac</li>
  <li>Src，6 bytes Mac</li>
  <li>Type，2 bytes. 表示不同的网络层协议，ethernet 不止支持 IP 协议。网络层协议的多路复用。arp 也属于不同的 type</li>
  <li>CRC， 4 bytes</li>
  <li>Preamble 8 bytes. 前个7个是 10101010，第八个是 10101011。用于接收适配器与发送适配器时钟同步。</li>
</ul>

<p>ethernet 提供的是不可靠无连接的服务</p>

<p>ethernet falvors</p>

<ul>
  <li>10BASE-T</li>
  <li>10BASE-2</li>
  <li>100BASE-LX</li>
  <li>10GBASE-T</li>
  <li>etc</li>
</ul>

<p>第一部分的数字表示速率，没带 G 单位是 M。“BASE”是指基带以太网，这意味着物理介质仅承载以太网流量。 最后部分表示物理介质，T 表示双绞线，另外还有光纤、同轴线缆</p>

<h3 id="链路层交换">链路层交换</h3>

<p>switch table，保存 Mac 地址与接口的对应关系。</p>

<ul>
  <li>Filtering 决定接收到的包丢弃还是转发，如果目标与来源接口相同则丢弃</li>
  <li>Forwarding 如果目标地址不在表中或地址是广播地址，则广播到除来源接口外的所有接口。目标地址有对应接口，转发到对应接口.</li>
</ul>

<p>switch table 是自学习的</p>

<ul>
  <li>在接收到的帧中提取 Mac 与接口的关系。</li>
  <li>达到老化时间后移除纪录</li>
</ul>

<p>交换机的特点</p>

<ul>
  <li>没有冲突</li>
  <li>异构 links，同一个网络可支持不同速率</li>
  <li>可管理</li>
</ul>

<p>路由与交换机的对比</p>

<ul>
  <li>交换机，使用最小生成树，避免回路，不是最优化。路由使用路由算法，选择最优路径，不过可能造成回路，需要 TTL。</li>
  <li>交换机，二层交换比路由三层交换更省时间</li>
</ul>

<h3 id="vlan">VLAN</h3>

<p>VLAN 间的交换</p>

<p>VLAN trunk，可实现跨交换机间的 VLAN 划分。发送方交换机的 trunk 接口会给 frame 打上标签（802.1Q 标准）。接收交换机会通过标签获取 vlan 信息，再恢复成标准的以太网帧再转发到特定的 vlan 中。</p>

<h2 id="链路虚拟化">链路虚拟化</h2>

<p>MPLS，多协议标签交换。用 ehternet 头与 ip 头之间插入的标签，来转发。</p>

<p>ISP 用 MPLS 来实现 VPN</p>

<h2 id="数据中心网络">数据中心网络</h2>

<ul>
  <li>ECMP</li>
  <li>RDMA</li>
</ul>

<h1 id="无线与移动网络">无线与移动网络</h1>

<ul>
  <li>无线主机</li>
  <li>无线链路</li>
  <li>基站
    <ul>
      <li>蜂窝网络中的蜂窝塔</li>
      <li>802.11无线局域网中的接入点</li>
    </ul>
  </li>
  <li>网络基础设施，主机通过基站链接到目标的网络</li>
</ul>

<p>在最高层，我们可以根据两个标准对无线网络进行分类：（i）无线网络中的数据包是恰好跨越一个无线跳（hop）还是多个无线跳，以及（ii）网络中是否有基站等基础设施：</p>

<ul>
  <li>单跳有基站，802.11 wifi、4G LTE</li>
  <li>单跳无基站，Bluetooth</li>
  <li>多跳有基站，wireless mesh networks</li>
  <li>多跳无基站。MANETS、VANET（车载随意移动网络）</li>
</ul>

<h2 id="无线链路和网络特征">无线链路和网络特征</h2>

<p>相比有线链路</p>

<ul>
  <li>path loss，传播过程中信号衰减</li>
  <li>不同源互相干扰</li>
  <li>多径传播，因为空间的不同发射，导致同样的信号不同时到达</li>
</ul>

<p>host 接收到的电磁信号，是发射信号的退化叠加背景噪音</p>

<ul>
  <li>SNR 信噪比</li>
  <li>BER 比特错误率</li>
</ul>

<p>对于给定的调制方案，信噪比越高，BER就越低</p>

<h3 id="cdma">CDMA</h3>

<p>CDMA，将原始信号乘以一个CDMA code \(c_m\) ，M 是 code 的长度。</p>

<ul>
  <li>发送 \(d_i\)，编码为 $$ Z_{i,m}=C_m*d_i</li>
  <li>接收 \(Z_{i,m}\)，解码 \(d_i = \frac{\sum\limits_{m=1}^{M}Z_{i,m}*C_m}{M}\)</li>
</ul>

<p>不同的接收者通过选择特定的 CDMA code，使得接收方仍能通过解码公式获取正确的解码来实现抗干扰。</p>

<h2 id="wifi80211-无线局域网">Wifi：802.11 无线局域网</h2>

<ul>
  <li>WLAN 802.11 b, g, n, ac, ax 向后兼容，相同的帧格式</li>
  <li>802.11 af IoT</li>
</ul>

<p>n, ac, ax 使用 MIMO 天线，表示在接收方和发送方有两个或更多的天线</p>

<p>ac, ax, 自适应波束形成（adaptively beamform）</p>

<h3 id="wlan-架构">WLAN 架构</h3>

<p>basic service set，由多个无线工作站和一个基站（AP）组成。</p>

<p>ad-hoc，多个工作站互联，无中央基站无外部网络链接。</p>

<p>在802.11中，每个无线站都需要与AP关联，然后才能发送或接收网络层数据。</p>

<p>AP 需要</p>

<ul>
  <li>SSID（Service Set Identifier）</li>
  <li>channel number</li>
</ul>

<p>2.4GHz，频宽 85MHz 定义了 11 个信道。相隔超过4的信道不重叠</p>

<ul>
  <li>连接（associate），连接意味着无线设备在自己和AP之间创建虚拟电线。</li>
  <li>802.11标准要求AP定期发送信标帧，每个信标帧都包括AP的SSID和MAC地址。</li>
  <li>扫描信道，监听信标帧的过程称为被动扫描</li>
  <li>主动扫描，无线设备主动广播探针帧（probe frame），AP 回应</li>
  <li>连接过程，需要一次 associate 握手，request/response</li>
</ul>

<h3 id="80211-mac-protocol">802.11 MAC Protocol</h3>

<ul>
  <li>CSMA/CA，与 Ethernet 的区别主要在于 CA，collision avoidance</li>
  <li>链路层响应重传 ARQ</li>
</ul>

<p>发送帧的步骤</p>

<ol>
  <li>无线站检测到信道空闲时，等待一个短暂的时间（DIFS）（减少有传播中未到达的帧的概率？？），然后开始发送帧</li>
  <li>如果信道繁忙，通过 BEB 算法选择一个等待值 count，在每个 DIFS 感知信道如果空闲则 c–，忙碌 count 不变。</li>
  <li>当 count 为 0 时，发送帧并等待 ACK</li>
  <li>如果 ACK 并且有帧要发，重复步骤 2，如果收不到 ACK 帧则执行回退并重复步骤 2</li>
</ol>

<p>CA 与不像 CD ，冲突发生时无法中断帧传输，要尽最大可能避免冲突。</p>

<p>RTS/CTS，解决隐藏终端问题，降低冲突机率</p>

<ul>
  <li>无线站发生帧之前，先发送一个短帧 Request to Send（RTS）</li>
  <li>AP 会回应并广播 Clear to Send（CTS）</li>
  <li>发送方接收到 CTS 才会进入发送帧的流程</li>
  <li>其他无线站接收到 CTS 会等待帧的发送时间</li>
</ul>

<p>RTS/CTS 是短帧，冲突的成本较低，一旦 RTS/CTS 成功握手了，数据帧就不会冲突
RTS/CTS 会增加延迟消耗信道资源</p>

<h3 id="80211-帧">802.11 帧</h3>

<p>拥有 4 个地址字段</p>

<ul>
  <li>A2，Sender</li>
  <li>A1，Receiver</li>
  <li>A3, destination，802.11 帧转换为 ethernet 帧对应的目标地址</li>
  <li>A4, ad hoc</li>
</ul>

<h3 id="移动性">移动性</h3>

<p>同个子网内切换 AP 是无感的，工作站的 IP 保持不变，可以保持上层的 TCP 连接不断。</p>

<ul>
  <li>工作站做的只需断开旧 AP 连接到新的 AP</li>
  <li>交换机要如何直到工作站切换了 AP。AP 可以通过以工作站 MAC 为源发一个广播包，更新交换机的关系表。</li>
</ul>

<h3 id="80211-高级特性">802.11 高级特性</h3>

<ol>
  <li>Rate Adaption，类似 TCP 的阻塞控制</li>
  <li>Power Management。没有帧可以发送或接收的节点可以99%的时间处于休眠状态。</li>
</ol>

<h3 id="蓝牙">蓝牙</h3>

<p>frequency-hopping spread spectrum (FHSS),</p>

<ul>
  <li>neighbor discovery
邻居的发现。maser 通过广播一系列32条查询消息来做到这一点，每条查询消息都在不同的频率信道上，并重复传输序列多达128次。客户端设备按其选择的频率监听，希望在此频率上听到 Master 的查询消息之一。当它听到查询消息时，它会随机回退0到0.3秒的时间，然后用包含其设备ID的消息响应主服务器。</li>
  <li>paging</li>
</ul>

<h2 id="蜂窝网络">蜂窝网络</h2>

<p>3GPP</p>

<ul>
  <li>IMSI，SIM。识别全球蜂窝移动运营商网络系统中的订阅者</li>
</ul>

</article>
<div class="tag-container" >
    
</div>


<div id="disqus_thread"></div>
<script>

 /**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
 var jekyll_id = "/notes/Quick/2021/04/note-2021-04-08"
 var disqus_config = function () {
     this.page.title = "2021年04月08日杂记"
     this.page.identifier = "posts"+jekyll_id.substring(jekyll_id.lastIndexOf('/'))+".md"; // required: replace example with your forum shortname
     console.log(this.page.identifier);
     this.page.url = "http://dourok.info/notes/Quick/2021/04/note-2021-04-08/";
    };

 (function() { // DON'T EDIT BELOW THIS LINE
     var d = document, s = d.createElement('script');
     s.src = '//doousblog.disqus.com/embed.js';
     s.setAttribute('data-timestamp', +new Date());
     (d.head || d.body).appendChild(s);
 })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>




<a class="btn-floating btn-large waves-effect waves-light scale-transition fab" id="fab"><i class="material-icons">keyboard_arrow_up</i></a>
</div>
    <div class="col hide-on-small-only m1 xl1 ">
        <a class="btn-floating teal" id='toc-toggle'><i id='toc-toogle-icon' class="material-icons">compare_arrows</i></a>
      </div>
    <div class="col hide-on-small-only m3 xl3 offset-xl1 toc-wrapper">
      <ul class="section table-of-contents">
      </ul>
    </div>
  </button>
</div>
</main>

<footer>
    <div class="container">
        <div class="row">
            <div class="col s12 m5 offset-m1">
                <h5>友情链接</h5>
                <ul class="mdl-mega-footer__link-list">
                    
                    <li><a href="https://magicalboy.com/">MAGICALBOY</a></li>
                    
                    <li><a href="http://www.cnlvzi.com/">驴子博客</a></li>
                    
                </ul>
            </div>
            <div class="col s12 m5">
                <div class="footer-nav">
                    
                    <a href="/">主页</a>
                    
                    <a href="/notes">笔记</a>
                    
                    <a href="/categories#coder-ref">编码</a>
                    
                    <a href="/categories#life-ref">生活</a>
                    
                    <a href="/categories#otaku-ref">兴趣</a>
                    
                    <a href="/tags">标签</a>
                    
                    <a href="/log">日志</a>
                    
                    <a href="/help">帮助</a>
                    
                    <a href="/about">关于</a>
                    
                </div>
        </div>
        </div>
    </div>
    <div class="footer-copyright">
        <div class="container">
            <div class="row">
                <div class="col offset-m1">
                    ©2009-世界末日 | 基於 <a href="https://jekyllrb.com">Jekyll</a> | 主题 <a href="#">Moon</a> | <small class="license">
	                  <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh"><img title="知识共享许可协议" style="border-width: 0px; vertical-align: middle; display: inline; " src="https://i.creativecommons.org/l/by-nc-sa/3.0/80x15.png" original="https://i.creativecommons.org/l/by-nc-sa/3.0/80x15.png"></a>
	                  </small>
                </div>
            </div>
        </div>
    </div>
</footer>



        

        
        <script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

        

        
    </body>

</html>
